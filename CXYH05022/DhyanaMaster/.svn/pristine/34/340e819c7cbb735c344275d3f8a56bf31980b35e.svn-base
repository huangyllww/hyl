/* $NoKeywords:$ */
/**
 * @file
 *
 * APCB.h
 *
 * AGESA PSP Customization Block
 *
 * @xrefitem bom "File Content Label" "Release Content"
 * @e project: AGESA
 * @e sub-project: (Mem)
 * @e \$Revision:  $ @e \$Date: $
 *
 **/
/*****************************************************************************
*
 * 
 * Copyright 2016 - 2019 CHENGDU HAIGUANG IC DESIGN CO., LTD. All Rights Reserved.
 * 
 * HYGON is granting you permission to use this software (the Materials)
 * pursuant to the terms and conditions of your Software License Agreement
 * with HYGON.  This header does *NOT* give you permission to use the Materials
 * or any rights under HYGON's intellectual property.  Your use of any portion
 * of these Materials shall constitute your acceptance of those terms and
 * conditions.  If you do not agree to the terms and conditions of the Software
 * License Agreement, please do not use any portion of these Materials.
 * 
 * CONFIDENTIALITY:  The Materials and all other information, identified as
 * confidential and provided to you by HYGON shall be kept confidential in
 * accordance with the terms and conditions of the Software License Agreement.
 * 
 * LIMITATION OF LIABILITY: THE MATERIALS AND ANY OTHER RELATED INFORMATION
 * PROVIDED TO YOU BY HYGON ARE PROVIDED "AS IS" WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTY OF ANY KIND, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
 * MERCHANTABILITY, NONINFRINGEMENT, TITLE, FITNESS FOR ANY PARTICULAR PURPOSE,
 * OR WARRANTIES ARISING FROM CONDUCT, COURSE OF DEALING, OR USAGE OF TRADE.
 * IN NO EVENT SHALL HYGON OR ITS LICENSORS BE LIABLE FOR ANY DAMAGES WHATSOEVER
 * (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF PROFITS, BUSINESS
 * INTERRUPTION, OR LOSS OF INFORMATION) ARISING OUT OF HYGON'S NEGLIGENCE,
 * GROSS NEGLIGENCE, THE USE OF OR INABILITY TO USE THE MATERIALS OR ANY OTHER
 * RELATED INFORMATION PROVIDED TO YOU BY HYGON, EVEN IF HYGON HAS BEEN ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGES.  BECAUSE SOME JURISDICTIONS PROHIBIT THE
 * EXCLUSION OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES,
 * THE ABOVE LIMITATION MAY NOT APPLY TO YOU.
 * 
 * HYGON does not assume any responsibility for any errors which may appear in
 * the Materials or any other related information provided to you by HYGON, or
 * result from use of the Materials or any related information.
 * 
 * You agree that you will not reverse engineer or decompile the Materials.
 * 
 * NO SUPPORT OBLIGATION: HYGON is not obligated to furnish, support, or make any
 * further information, software, technical information, know-how, or show-how
 * available to you.  Additionally, HYGON retains the right to modify the
 * Materials at any time, without notice, and is not obligated to provide such
 * modified Materials to you.
 * 
 * AMD GRANT HYGON DECLARATION: ADVANCED MICRO DEVICES, INC.(AMD) granted HYGON has
 * the right to redistribute HYGON's Agesa version to BIOS Vendors and HYGON has
 * the right to make the modified version available for use with HYGON's PRODUCT.
* ***************************************************************************
*
*/

#ifndef _APCB_H_
#define _APCB_H_

#include <ApcbCommon.h>
#include "PlatformMemoryConfiguration.h"
#include "mm.h"
#include "mn.h"
#include "mnreg.h"
//#include "mempmu.h"
#include "mp.h"
/*----------------------------------------------------------------------------
 *   Mixed (DEFINITIONS AND MACROS / TYPEDEFS, STRUCTURES, ENUMS)
 *
 *----------------------------------------------------------------------------
 */

/*-----------------------------------------------------------------------------
 *                         DEFINITIONS AND MACROS
 *
 *-----------------------------------------------------------------------------
 */

/*----------------------------------------------------------------------------
 *                         TYPEDEFS, STRUCTURES, ENUMS
 *
 *----------------------------------------------------------------------------
 */
#define APCB_HEADER_VERSION     0x00000028  // APCB Version

#define APCB_MAX_SOCKETS_SUPPORTED 1  /// Max Sockets supproted by APCB
#define APCB_MAX_CHANNEL_PER_SOCKET 2
#define APCB_MAX_DIMMS_PER_CHANNEL  2
#define APCB_TOTAL_SYSTEM_DIMMS  (APCB_MAX_SOCKETS_SUPPORTED * APCB_MAX_CHANNEL_PER_SOCKET * APCB_MAX_DIMMS_PER_CHANNEL)

//
// Group Id and Type Id for Memory Specific Data
//

#define APCB_GROUP_PSP                                 0x1701
#define APCB_GROUP_CCX                                 0x1702
#define APCB_GROUP_DF                                  0x1703
#define APCB_GROUP_MEMORY                              0x1704
#define APCB_GROUP_GNB                                 0x1705
#define APCB_GROUP_FCH                                 0x1706
#define APCB_GROUP_CBS                                 0x1707

#define APCB_ENABLED                                   1
#define APCB_MANUAL                                    1
#define APCB_AUTO_U8                                   0xFF
#define APCB_AUTO_U16                                  0xFFFF
#define APCB_AUTO_U32                                  0xFFFFFFFFul
#define APCB_AUTO_U64                                  0xFFFFFFFFFFFFFFFFull

typedef enum {
  APCB_PSP_TYPE_CONFIG_DEFAULT_PARAMETERS = 1,
  APCB_PSP_TYPE_CONFIG_PARAMETERS,
  APCB_CCX_TYPE_CONFIG_DEFAULT_PARAMETERS = 3,
  APCB_CCX_TYPE_CONFIG_PARAMETERS,
  APCB_DF_TYPE_CONFIG_DEFAULT_PARAMETERS = 5,
  APCB_DF_TYPE_CONFIG_PARAMETERS,
  APCB_MEM_TYPE_CONFIG_DEFAULT_PARAMETERS = 7,
  APCB_MEM_TYPE_CONFIG_PARAMETERS,
  APCB_GNB_TYPE_CONFIG_DEFAULT_PARAMETERS = 9,
  APCB_GNB_TYPE_CONFIG_PARAMETERS,
  APCB_FCH_TYPE_CONFIG_DEFAULT_PARAMETERS = 11,
  APCB_FCH_TYPE_CONFIG_PARAMETERS,
  APCB_TYPE_CBS_COMMON_PARAMETERS = 13,
  APCB_TYPE_CBS_COMMON_DUMMY_PARAMETERS,
  APCB_TYPE_CBS_DEBUG_PARAMETERS = 15,
  APCB_TYPE_CBS_DEBUG_DUMMY_PARAMETERS
} APCB_PARAM_TYPE;

#define APCB_MEM_TYPE_SPD_INFO                0x0030
#define APCB_MEM_TYPE_DIMM_INFO_SMBUS         0x0031
#define APCB_MEM_TYPE_DIMM_CONFIG_INFO_ID     0x0032
#define APCB_MEM_TYPE_MEM_OVERCLOCK_CONFIG    0x0033

#define APCB_MEM_TYPE_PSO_DATA                0x0040

#define APCB_MEM_TYPE_PS_UDIMM_DDR4_ODT_PAT   0x0041
#define APCB_MEM_TYPE_PS_UDIMM_DDR4_CAD_BUS   0x0042
#define APCB_MEM_TYPE_PS_UDIMM_DDR4_DATA_BUS  0x0043
#define APCB_MEM_TYPE_PS_UDIMM_DDR4_MAX_FREQ  0x0044
#define APCB_MEM_TYPE_PS_UDIMM_DDR4_STRETCH_FREQ  0x0045

#define APCB_MEM_TYPE_PS_RDIMM_DDR4_ODT_PAT   0x0046
#define APCB_MEM_TYPE_PS_RDIMM_DDR4_CAD_BUS   0x0047
#define APCB_MEM_TYPE_PS_RDIMM_DDR4_DATA_BUS  0x0048
#define APCB_MEM_TYPE_PS_RDIMM_DDR4_MAX_FREQ  0x0049
#define APCB_MEM_TYPE_PS_RDIMM_DDR4_STRETCH_FREQ  0x004A

#define APCB_MEM_TYPE_CONSOLE_OUT_CONTROL     0x0050
#define APCB_MEM_TYPE_EVENT_CONTROL           0x0051
#define APCB_MEM_TYPE_ERROR_OUT_EVENT_CONTROL 0x0052
#define APCB_MEM_TYPE_EXT_VOLTAGE_CONTROL     0x0053

#define APCB_MEM_TYPE_PS_LRDIMM_DDR4_ODT_PAT  0x0054
#define APCB_MEM_TYPE_PS_LRDIMM_DDR4_CAD_BUS  0x0055
#define APCB_MEM_TYPE_PS_LRDIMM_DDR4_DATA_BUS 0x0056
#define APCB_MEM_TYPE_PS_LRDIMM_DDR4_MAX_FREQ 0x0057
#define APCB_MEM_TYPE_PS_LRDIMM_DDR4_STRETCH_FREQ 0x0058

#define APCB_MEM_TYPE_PS_SODIMM_DDR4_ODT_PAT  0x0059
#define APCB_MEM_TYPE_PS_SODIMM_DDR4_CAD_BUS  0x005A
#define APCB_MEM_TYPE_PS_SODIMM_DDR4_DATA_BUS 0x005B
#define APCB_MEM_TYPE_PS_SODIMM_DDR4_MAX_FREQ 0x005C
#define APCB_MEM_TYPE_PS_SODIMM_DDR4_STRETCH_FREQ 0x005D

#define APCB_MEM_TYPE_DDR_POST_PACKAGE_REPAIR 0x005E
#define APCB_MEM_TYPE_PS_DRAMDOWN_DDR4_ODT_PAT  0x0070
#define APCB_MEM_TYPE_PS_DRAMDOWN_DDR4_CAD_BUS  0x0071
#define APCB_MEM_TYPE_PS_DRAMDOWN_DDR4_DATA_BUS 0x0072
#define APCB_MEM_TYPE_PS_DRAMDOWN_DDR4_MAX_FREQ 0x0073
#define APCB_MEM_TYPE_PS_DRAMDOWN_DDR4_STRETCH_FREQ 0x0074

#define APCB_PSP_TYPE_BOARD_ID_GETTING_METHOD     0x0060

/// CBS Items Start
#define BSU08(u8)     ((UINT8) (u8)  & 0xFF)
#define BSU16(u16)    ((UINT16) (u16) & 0xFF), (((UINT16) (u16) >> 8) & 0xFF)
#define BSU32(u32)    ((UINT32) (u32) & 0xFF), (((UINT32) (u32) >> 8) & 0xFF), (((UINT32) (u32) >> 16) & 0xFF), (((UINT32) (u32) >> 24) & 0xFF)
#define BSU64(u64)    ((UINT64) (u64) & 0xFF), (((UINT64) (u64) >> 8) & 0xFF), (((UINT64) (u64) >> 16) & 0xFF), (((UINT64) (u64) >> 24) & 0xFF), \
                      (((UINT64) (u64) >> 32) & 0xFF), (((UINT64) (u64) >> 40) & 0xFF), (((UINT64) (u64) >> 48) & 0xFF), (((UINT64) (u64) >> 56) & 0xFF)
#define BSBLN(bl)     ((UINT8) (bl)  & 0xFF)

//
// DF Type ID
//
#define APCB_DF_TYPE_XGMI_TX_EQ                     0x00D0
#define   APCB_DF_TYPE_XGMI_INSTANCE_SPEED_COMBINED   0   // Instance ID 0
#define   APCB_DF_TYPE_XGMI_INSTANCE_SPEED_COMBINED_1 1   // Instance ID 1

//
// The enumerator should always grow at the end of the list of each component
// Obsolete tokens should be preserved to maintain backward compatibility
//
typedef enum {
  APCB_TOKEN_CONFIG_PSP_BEGIN = 0x0,
  APCB_TOKEN_CONFIG_PSP_ENABLE_DEBUG_MODE,
  APCB_TOKEN_CONFIG_PSP_END,
  APCB_TOKEN_CONFIG_CCX_BEGIN = 0x100,
  APCB_TOKEN_CONFIG_CCX_MIN_SEV_ASID,
  APCB_TOKEN_CONFIG_CCX_END,
  APCB_TOKEN_CONFIG_DF_BEGIN = 0x300,
  APCB_TOKEN_CONFIG_DF_GMI_ENCRYPT,
  APCB_TOKEN_CONFIG_DF_XGMI_ENCRYPT,
  APCB_TOKEN_CONFIG_DF_SAVE_RESTORE_MEM_ENCRYPT,
  APCB_TOKEN_CONFIG_DF_SYS_STORAGE_AT_TOP_OF_MEM,
  APCB_TOKEN_CONFIG_DF_PROBE_FILTER_ENABLE,
  APCB_TOKEN_CONFIG_DF_BOTTOMIO,
  APCB_TOKEN_CONFIG_DF_MEM_INTERLEAVING,
  APCB_TOKEN_CONFIG_DF_DRAM_INTERLEAVE_SIZE,
  APCB_TOKEN_CONFIG_DF_ENABLE_CHAN_INTLV_HASH,
  APCB_TOKEN_CONFIG_DF_PCI_MMIO_SIZE,
  APCB_TOKEN_CONFIG_DF_CAKE_CRC_THRESH_PERF_BOUNDS,
  APCB_TOKEN_CONFIG_DF_MEM_CLEAR,
  APCB_TOKEN_CONFIG_DF_BUS_NUM_ASSIGN_STRATEGY,
  APCB_TOKEN_CONFIG_DF_END,
  APCB_TOKEN_CONFIG_MEM_BEGIN = 0x700,
  APCB_TOKEN_CONFIG_BOTTOMIO,
  APCB_TOKEN_CONFIG_MEMHOLEREMAPPING,
  APCB_TOKEN_CONFIG_LIMITMEMORYTOBELOW1TB,
  APCB_TOKEN_CONFIG_USERTIMINGMODE,
  APCB_TOKEN_CONFIG_MEMCLOCKVALUE,
  APCB_TOKEN_CONFIG_ENABLECHIPSELECTINTLV,
  APCB_TOKEN_CONFIG_ENABLECHANNELINTLV,
  APCB_TOKEN_CONFIG_ENABLEECCFEATURE,
  APCB_TOKEN_CONFIG_ENABLEPOWERDOWN,
  APCB_TOKEN_CONFIG_ENABLEPARITY,
  APCB_TOKEN_CONFIG_ENABLEBANKSWIZZLE,
  APCB_TOKEN_CONFIG_ENABLEMEMCLR,
  APCB_TOKEN_CONFIG_UMAMODE,
  APCB_TOKEN_CONFIG_UMASIZE,
  APCB_TOKEN_CONFIG_MEMRESTORECTL,
  APCB_TOKEN_CONFIG_SAVEMEMCONTEXTCTL,
  APCB_TOKEN_CONFIG_ISCAPSULEMODE,
  APCB_TOKEN_CONFIG_FORCETRAINMODE,
  APCB_TOKEN_CONFIG_DIMMTYPEUSEDINMIXEDCONFIG,
  APCB_TOKEN_CONFIG_AMPENABLE,
  APCB_TOKEN_CONFIG_DRAMDOUBLEREFRESHRATE,
  APCB_TOKEN_CONFIG_PMUTRAINMODE,
  APCB_TOKEN_CONFIG_ECCREDIRECTION,
  APCB_TOKEN_CONFIG_SCRUBDRAMRATE,
  APCB_TOKEN_CONFIG_SCRUBL2RATE,
  APCB_TOKEN_CONFIG_SCRUBL3RATE,
  APCB_TOKEN_CONFIG_SCRUBICRATE,
  APCB_TOKEN_CONFIG_SCRUBDCRATE,
  APCB_TOKEN_CONFIG_ECCSYNCFLOOD,
  APCB_TOKEN_CONFIG_ECCSYMBOLSIZE,
  APCB_TOKEN_CONFIG_DQSTRAININGCONTROL,
  APCB_TOKEN_CONFIG_UMAABOVE4G,
  APCB_TOKEN_CONFIG_UMAALIGNMENT,
  APCB_TOKEN_CONFIG_MEMORYALLCLOCKSON,
  APCB_TOKEN_CONFIG_MEMORYBUSFREQUENCYLIMIT,
  APCB_TOKEN_CONFIG_POWERDOWNMODE,
  APCB_TOKEN_CONFIG_IGNORESPDCHECKSUM,
  APCB_TOKEN_CONFIG_MEMORYMODEUNGANGED,
  APCB_TOKEN_CONFIG_MEMORYQUADRANKCAPABLE,
  APCB_TOKEN_CONFIG_MEMORYRDIMMCAPABLE,
  APCB_TOKEN_CONFIG_MEMORYLRDIMMCAPABLE,
  APCB_TOKEN_CONFIG_MEMORYUDIMMCAPABLE,
  APCB_TOKEN_CONFIG_MEMORYSODIMMCAPABLE,
  APCB_TOKEN_CONFIG_DRAMDOUBLEREFRESHRATEEN,
  APCB_TOKEN_CONFIG_DIMMTYPEDDDR4CAPABLE,
  APCB_TOKEN_CONFIG_DIMMTYPEDDDR3CAPABLE,
  APCB_TOKEN_CONFIG_DIMMTYPELPDDDR3CAPABLE,
  APCB_TOKEN_CONFIG_ENABLEZQRESET,
  APCB_TOKEN_CONFIG_ENABLEBANKGROUPSWAP,
  APCB_TOKEN_CONFIG_ODTSCMDTHROTEN,
  APCB_TOKEN_CONFIG_SWCMDTHROTEN,
  APCB_TOKEN_CONFIG_FORCEPWRDOWNTHROTEN,
  APCB_TOKEN_CONFIG_ODTSCMDTHROTCYC,
  APCB_TOKEN_CONFIG_SWCMDTHROTCYC,
  APCB_TOKEN_CONFIG_DIMMSENSORCONF,
  APCB_TOKEN_CONFIG_DIMMSENSORUPPER,
  APCB_TOKEN_CONFIG_DIMMSENSORLOWER,
  APCB_TOKEN_CONFIG_DIMMSENSORCRITICAL,
  APCB_TOKEN_CONFIG_DIMMSENSORRESOLUTION,
  APCB_TOKEN_CONFIG_AUTOREFFINEGRANMODE,
  APCB_TOKEN_CONFIG_ENABLEMEMPSTATE,
  APCB_TOKEN_CONFIG_SOLDERDOWNDRAM,
  APCB_TOKEN_CONFIG_DDRROUTEBALANCEDTEE,
  APCB_TOKEN_CONFIG_MEM_MBIST_TEST_ENABLE,
 // APCB_TOKEN_CONFIG_MEM_MBIST_TESTMODE,
  APCB_TOKEN_CONFIG_MEM_MBIST_SUBTEST_TYPE,
  APCB_TOKEN_CONFIG_MEM_MBIST_AGGRESOR_ON,
  APCB_TOKEN_CONFIG_MEM_MBIST_HALT_ON_ERROR,
  APCB_TOKEN_CONFIG_MEM_CPU_VREF_RANGE,
  APCB_TOKEN_CONFIG_MEM_DRAM_VREF_RANGE,
  APCB_TOKEN_CONFIG_MEM_TSME_ENABLE,
  APCB_TOKEN_CONFIG_MEM_NVDIMM_POWER_SOURCE,
  APCB_TOKEN_CONFIG_MEM_DATA_POISON,
  APCB_TOKEN_CONFIG_MEM_DATA_SCRAMBLE,
  APCB_TOKEN_CONFIG_MEM_PS_ERROR_HANDLING,
  APCB_TOKEN_CONFIG_MEM_TEMP_CONTROLLED_REFRESH_EN,
  APCB_TOKEN_CONFIG_MEM_MBIST_PER_BIT_SLAVE_DIE_REPORT,
  APCB_TOKEN_CONFIG_MEM_1SPC_2SPC_MIXED_MODE_EN,
//  APCB_TOKEN_CONFIG_ENABLEBANKGROUPSWAPALT, 
  APCB_TOKEN_CONFIG_MEM_END,
  APCB_TOKEN_CONFIG_GNB_BEGIN = 0x1800,
  APCB_TOKEN_CONFIG_BMC_SOCKET_NUMBER,
  APCB_TOKEN_CONFIG_BMC_START_LANE,
  APCB_TOKEN_CONFIG_BMC_END_LANE,
  APCB_TOKEN_CONFIG_BMC_DEVICE,
  APCB_TOKEN_CONFIG_BMC_FUNCTION,
//  APCB_TOKEN_CONFIG_PCIE_RESET_CONTROL,
  APCB_TOKEN_CONFIG_GNB_END,
  APCB_TOKEN_CONFIG_FCH_BEGIN = 0x1C00,
  APCB_TOKEN_CONFIG_FCH_CONSOLE_OUT_ENABLE,
  APCB_TOKEN_CONFIG_FCH_CONSOLE_OUT_SERIAL_PORT,
  APCB_TOKEN_CONFIG_FCH_END,
  APCB_TOKEN_CONFIG_LIMIT = 0x1FFF
} APCB_PARAM_CONFIG_TOKEN;

// Note: Ensure that the token name matches the variable name in CBS xml file/
//       ApcbAutoGen.h file in Resource folder in CBS package.
//
// CBS CMN APCB Tokens
//
#define APCB_TOKEN_CBS_CMN_BEGIN 0x0000
#define APCB_TOKEN_CBS_DF_CMN_GMI_ENCRYPTION 0x0001
#define APCB_TOKEN_CBS_DF_CMN_X_GMI_ENCRYPTION 0x0002
#define APCB_TOKEN_CBS_DF_CMN_CC6_MEM_ENCRYPTION 0x0003
#define APCB_TOKEN_CBS_DF_CMN_CC6_ALLOCATION_SCHEME 0x0004
#define APCB_TOKEN_CBS_DF_CMN_SYS_PROBE_FILTER 0x0005
#define APCB_TOKEN_CBS_DF_CMN_MEM_INTLV 0x0006
#define APCB_TOKEN_CBS_DF_CMN_MEM_INTLV_SIZE 0x0007
#define APCB_TOKEN_CBS_DF_CMN_CHNL_INTLV_HASH 0x0008
#define APCB_TOKEN_CBS_CMN_MEM_MAPPING_BANK_INTERLEAVE_DDR4 0x0009
#define APCB_TOKEN_CBS_CMN_MEM_CTRLLER_BANK_GROUP_SWAP_DDR4 0x000A
#define APCB_TOKEN_CBS_CMN_MEM_CTRLLER_BANK_SWIZZLE_DDR4 0x000B
#define APCB_TOKEN_CBS_CMN_MEM_ADDRESS_HASHING_DDR4 0x000C
#define APCB_TOKEN_CBS_CMN_MEM_SPEED_DDR4 0x000D
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TCL_DDR4 0x000E
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TRCDRD_DDR4 0x000F
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TRCDWR_DDR4 0x0010
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TRP_DDR4 0x0011
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TRAS_DDR4 0x0012
#define APCB_TOKEN_CBS_CMN_MEM_DATA_POISONING_DDR4 0x0013
#define APCB_TOKEN_CBS_CMN_MEM_ADDRESS_HASH_BANK_DDR4 0x0014
#define APCB_TOKEN_CBS_CMN_MEM_ADDRESS_HASH_CS_DDR4 0x0015
#define APCB_TOKEN_CBS_CMN_MEM_TSME_DDR4 0x0016
#define APCB_TOKEN_CBS_CMN_MEM_OVERCLOCK_DDR4 0x0017
#define APCB_TOKEN_CBS_CMN_GNB_GFX_UMA_MODE 0x0018
#define APCB_TOKEN_CBS_CMN_GNB_GFX_UMA_VERSION 0x0019
#define APCB_TOKEN_CBS_CMN_GNB_GFX_DISPLAY_RESOLUTION 0x001A
#define APCB_TOKEN_CBS_CMN_GNB_GFX_UMA_FRAME_BUFFER_SIZE 0x001B
#define APCB_TOKEN_CBS_CMN_CPU_SEV_ASID_SPACE_LIMIT 0x001C
#define APCB_TOKEN_CBS_CMN_MEM_SPD_READ_OPTIMIZATION_DDR4 0x001D
#define APCB_TOKEN_CBS_CMN_MEM_MBIST_EN 0x001E
#define APCB_TOKEN_CBS_CMN_MEM_MBIST_TESTMODE 0x001F
#define APCB_TOKEN_CBS_DF_CMN_MEM_CLEAR 0x0020
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TRC_CTRL_DDR4 0x0021
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TRC_DDR4 0x0022
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TRRD_S_DDR4 0x0023
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TRRD_L_DDR4 0x0024
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TFAW_CTRL_DDR4 0x0025
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TFAW_DDR4 0x0026
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TWTR_S_DDR4 0x0027
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TWTR_L_DDR4 0x0028
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TWR_CTRL_DDR4 0x0029
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TWR_DDR4 0x002A
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TRCPAGE_CTRL_DDR4 0x002B
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TRCPAGE_DDR4 0x002C
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TRDRD_SC_L_CTRL_DDR4 0x002D
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TRDRD_SC_L_DDR4 0x002E
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TWRWR_SC_L_CTRL_DDR4 0x002F
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TWRWR_SC_L_DDR4 0x0030
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TRFC_CTRL_DDR4 0x0031
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TRFC_DDR4 0x0032
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TRFC2_CTRL_DDR4 0x0033
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TRFC2_DDR4 0x0034
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TRFC4_CTRL_DDR4 0x0035
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TRFC4_DDR4 0x0036
#define APCB_TOKEN_CBS_CMN_MEM_OVERCLOCK_FAIL_CNT 0x0037
#define APCB_TOKEN_CBS_CMN_MEM_CTRLLER_PROC_ODT_DDR4 0x0038
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TRDRD_SC_DDR4 0x0039
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TRDRD_SD_DDR4 0x003A
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TRDRD_DD_DDR4 0x003B
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TWRWR_SC_DDR4 0x003C
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TWRWR_SD_DDR4 0x003D
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TWRWR_DD_DDR4 0x003E
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TRDWR_DDR4 0x003F
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TWRRD_DDR4 0x0040
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TRTP_DDR4 0x0041
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TCWL_DDR4 0x0042
#define APCB_TOKEN_CBS_CMN_MEM_DATA_BUS_CONFIG_CTL_DDR4 0x0043
#define APCB_TOKEN_CBS_CMN_MEM_CTRLLER_RTT_NOM_DDR4 0x0044
#define APCB_TOKEN_CBS_CMN_MEM_CTRLLER_RTT_WR_DDR4 0x0045
#define APCB_TOKEN_CBS_CMN_MEM_CTRLLER_RTT_PARK_DDR4 0x0046
#define APCB_TOKEN_CBS_CMN_MEM_TIMING_TCKE_DDR4 0x0047
#define APCB_TOKEN_CBS_CMN_MEM_CTRLLER_DATA_SCRAMBLE_DDR4 0x0048
#define APCB_TOKEN_CBS_CMN_CLDO_VDDP_CTL 0x0049
#define APCB_TOKEN_CBS_CMN_CLDOVDD_PVOLTAGE 0x004A
#define APCB_TOKEN_CBS_CMN_MEM_CTRLLER2_T_MODE_DDR4 0x004B
#define APCB_TOKEN_CBS_CMN_MEM_GEAR_DOWN_MODE_DDR4 0x004C
#define APCB_TOKEN_CBS_CMN_MEM_MBIST_AGGRESSORS 0x004D
#define APCB_TOKEN_CBS_CMN_MEM_MBIST_PER_BIT_SLAVE_DIE_REPORT 0x004E
#define APCB_TOKEN_CBS_CMN_MEM_CTRLLER_PWR_DN_EN_DDR4 0x004F
#define APCB_TOKEN_CBS_CMN_MEM_CAD_BUS_TIMING_CTL_DDR4 0x0050
#define APCB_TOKEN_CBS_CMN_MEM_ADDR_CMD_SETUP_DDR4 0x0051
#define APCB_TOKEN_CBS_CMN_BIOS_SPI_SPEED_MODE 0x0052
#define APCB_TOKEN_CBS_CMN_MEM_CKE_SETUP_DDR4 0x0053
#define APCB_TOKEN_CBS_CMN_MEM_CAD_BUS_DRV_STREN_CTL_DDR4 0x0054
#define APCB_TOKEN_CBS_CMN_MEM_CAD_BUS_CLK_DRV_STREN_DDR4 0x0055
#define APCB_TOKEN_CBS_CMN_MEM_CAD_BUS_ADDR_CMD_DRV_STREN_DDR4 0x0056
#define APCB_TOKEN_CBS_CMN_MEM_CAD_BUS_CS_ODT_DRV_STREN_DDR4 0x0057
#define APCB_TOKEN_CBS_CMN_MEM_CAD_BUS_CKE_DRV_STREN_DDR4 0x0058
#define APCB_TOKEN_CBS_CPU_RELAXED_EDC_THROTTLING 0x0059
#define APCB_TOKEN_CBS_CMN_MEM_CTRLLER_BANK_GROUP_SWAP_ALT_DDR4 0x005A
#define APCB_TOKEN_CBS_CMN_MEM_CTRLLER_DRAM_ECC_SYMBOL_SIZE_DDR4 0x005B
#define APCB_TOKEN_CBS_CMN_MEM_CTRLLER_DRAM_ECC_EN_DDR4 0x005C
#define APCB_TOKEN_CBS_CMN_AVS_CTRL 0x005D
#define APCB_TOKEN_CBS_CMN_END 0x005E
#define APCB_TOKEN_CBS_CMN_LIMIT 0x1FFF

//
// CBS DBG APCB Tokens
//
#define APCB_TOKEN_CBS_DBG_BEGIN 0x0000
#define APCB_TOKEN_CBS_DF_DBG_CORE_MSTR_REQ_ORDERING 0x0001
#define APCB_TOKEN_CBS_DF_DBG_IO_MSTR_REQ_ORDERING 0x0002
#define APCB_TOKEN_CBS_DF_DBG_MEM_CANCEL_DIS 0x0003
#define APCB_TOKEN_CBS_DF_DBG_MIG_PRB_DIS 0x0004
#define APCB_TOKEN_CBS_DF_DBG_STOP_ON_SPF_ERROR 0x0005
#define APCB_TOKEN_CBS_DF_DBG_TCDX_BYPASS_DIS 0x0006
#define APCB_TOKEN_CBS_DF_DBG_F1F_FETCH_PRB_RMT 0x0007
#define APCB_TOKEN_CBS_DF_DBG_F1F_FETCH_PRB_LCL 0x0008
#define APCB_TOKEN_CBS_DF_DBG_F1F_FETCH_PRB_TARGET 0x0009
#define APCB_TOKEN_CBS_DF_DBG_SPF_WAY_DIS 0x000A
#define APCB_TOKEN_CBS_DF_DBG_IO_REQ_BUS_LOCK_CTRL 0x000B
#define APCB_TOKEN_CBS_DF_DBG_IOM_PERF_MON_PRB_RSP 0x000C
#define APCB_TOKEN_CBS_DF_DBG_IOM_PERF_MON_TGT_SEL 0x000D
#define APCB_TOKEN_CBS_DF_DBG_WDT_CTRL 0x000E
#define APCB_TOKEN_CBS_DF_DBG_CAKE_REQ_ADDR_COMPRESSION 0x000F
#define APCB_TOKEN_CBS_DF_DBG_CAKE_DATA_COMPRESSION 0x0010
#define APCB_TOKEN_CBS_DF_DBG_CAKE_RSP_CMD_PACKING 0x0011
#define APCB_TOKEN_CBS_DF_DBG_CAKE_PRB_COMBINING 0x0012
#define APCB_TOKEN_CBS_DF_DBG_CAKE_IO_ADDR_COMP_BIT 0x0013
#define APCB_TOKEN_CBS_DF_DBG_IO_BUS_LOCK_INV_DIS 0x0014
#define APCB_TOKEN_CBS_DF_DBG_PIE_PRQ_BCST_LIMIT 0x0015
#define APCB_TOKEN_CBS_DF_DBG_LMT_MAX_IO_REQ_MASTER 0x0016
#define APCB_TOKEN_CBS_DF_DBG_LMT_MAX_IO_REQ_LIMIT 0x0017
#define APCB_TOKEN_CBS_DF_DBG_IOS_RSP_BYPASS_CTRL 0x0018
#define APCB_TOKEN_CBS_DF_DBG_CAKE_BYPASS_CTRL 0x0019
#define APCB_TOKEN_CBS_DF_DBG_CS_BYPASS_CTRL 0x001A
#define APCB_TOKEN_CBS_DF_DBG_TGT_START_CTRL 0x001B
#define APCB_TOKEN_CBS_DF_DBG_LINK_ERR_INJ 0x001C
#define APCB_TOKEN_CBS_DF_DBG_VC8_TRACING_TOK_ALLOC 0x001D
#define APCB_TOKEN_CBS_DF_DBG_VC8_TRACING_REQ_CS 0x001E
#define APCB_TOKEN_CBS_DF_DBG_VC8_TRACING_REQ_IOMS 0x001F
#define APCB_TOKEN_CBS_DF_DBG_VC8_TRACING_CSQ 0x0020
#define APCB_TOKEN_CBS_DF_DBG_VC8_TRACING_RSP_IOMS 0x0021
#define APCB_TOKEN_CBS_DF_DBG_VC8_TRACING_RSP_TCDX 0x0022
#define APCB_TOKEN_CBS_DF_DBG_REDUCE_CREDITS_REQ 0x0023
#define APCB_TOKEN_CBS_DF_DBG_REDUCE_CREDITS_PRB 0x0024
#define APCB_TOKEN_CBS_DF_DBG_REDUCE_CREDITS_RSP 0x0025
#define APCB_TOKEN_CBS_DF_DBG_LOAD_STEP_CTRL_DIS 0x0026
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_ENFORCE_FREQ_DDR4 0x0027
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_CTL_DDR4 0x0028
#define APCB_TOKEN_CBS_DBG_MEM_SPEED_DDR4 0x0029
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_UCLK_DIV1_M0_DDR4 0x002A
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_UCLK_DIV1_M1_DDR4 0x002B
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_UCLK_DIV1_M2_DDR4 0x002C
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_UCLK_DIV1_M3_DDR4 0x002D
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TCL_DDR4 0x002E
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TRCDRD_DDR4 0x002F
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TRCDWR_DDR4 0x0030
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TRP_DDR4 0x0031
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TRTP_DDR4 0x0032
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TRAS_DDR4 0x0033
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TRRD_L_DDR4 0x0034
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TRRD_S_DDR4 0x0035
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TRC_CTL_DDR4 0x0036
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TRC_DDR4 0x0037
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TRDWR_DDR4 0x0038
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TWRRD_DDR4 0x0039
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TWTR_L_DDR4 0x003A
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TWTR_S_DDR4 0x003B
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TWRWR_SC_DDR4 0x003C
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TWRWR_SD_DDR4 0x003D
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TWRWR_DD_DDR4 0x003E
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TRDRD_SC_DDR4 0x003F
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TRDRD_SD_DDR4 0x0040
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TRDRD_DD_DDR4 0x0041
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TREF_CTL_DDR4 0x0042
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TREF_DDR4 0x0043
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TRWT_WB_DDR4 0x0044
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TRFC0_CTL_DDR4 0x0045
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TRFC0_DDR4 0x0046
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TRFC1_CTL_DDR4 0x0047
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TRFC1_DDR4 0x0048
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TCKSRX_CTL_DDR4 0x0049
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TCKSRX_DDR4 0x004A
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TCKSRE_CTL_DDR4 0x004B
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TCKSRE_DDR4 0x004C
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TPD_CTL_DDR4 0x004D
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TPD_DDR4 0x004E
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_ADDR_CMD_TRI_EN_DDR4 0x004F
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER2_T_MODE_DDR4 0x0050
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_DATA_SCRAMBLE_DDR4 0x0051
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_ON_DIMM_TEMP_SENSOR_EN_DDR4 0x0052
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_CMD_THROTTLE_MODE_CTL_DDR4 0x0053
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_CMD_THROTTLE_MODE_DDR4 0x0054
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_WR_CRC_EN_DDR4 0x0055
#define APCB_TOKEN_CBS_DBG_MEM_GEAR_DOWN_MODE_DDR4 0x0056
#define APCB_TOKEN_CBS_DBG_MEM_HW_HISTORY_MECH_DDR4 0x0057
#define APCB_TOKEN_CBS_DBG_MEM_DRAM_PARITY_DDR4 0x0058
#define APCB_TOKEN_CBS_DBG_MEM_RCD_PARITY_DDR4 0x0059
#define APCB_TOKEN_CBS_DBG_MEM_DBI_DDR4 0x005A
#define APCB_TOKEN_CBS_DBG_MEM_ADDR_TWEAK_EN_CTRL_DDR4 0x005B
#define APCB_TOKEN_CBS_DBG_MEM_ADDR_TWEAK_EN_DDR4 0x005C
#define APCB_TOKEN_CBS_DBG_MEM_DATA_ENCRYPTION_DDR4 0x005D
#define APCB_TOKEN_CBS_DBG_MEM_FORCE_ENCRYPTION_DDR4 0x005E
#define APCB_TOKEN_CBS_DBG_MEM_FINE_GRAN_REF_DDR4 0x005F
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_PWR_DN_EN_DDR4 0x0060
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_PWR_DN_MO_DDR4 0x0061
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_PD_DLY_CTL_DDR4 0x0062
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_PD_DLY_DDR4 0x0063
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_AGGRESSIVE_PWR_DOWN_EN_DDR4 0x0064
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_AGGRE_PD_DLY_CTL_DDR4 0x0065
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_AGGRE_PD_DLY_DDR4 0x0066
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_PHY_POWER_SAVING_DDR4 0x0067
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_PD_PHY_POWER_SAVE_DIS_DDR4 0x0068
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_PHY_RECEIVER_POWER_MODE_DDR4 0x0069
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_MEM_PWR_POLICY_DDR4 0x006A
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_ALL_MEM_CLKS_DDR4 0x006B
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_ALL_CKE_DDR4 0x006C
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_ALL_CS_DDR4 0x006D
#define APCB_TOKEN_CBS_DBG_MEM_DATA_POISONING_DDR4 0x006E
#define APCB_TOKEN_CBS_DBG_MEM_ADDR_CMD_PARITY_RETRY_DDR4 0x006F
#define APCB_TOKEN_CBS_DBG_MEM_ADDR_CMD_PARITY_ERROR_MAX_REPLAY_DDR4 0x0070
#define APCB_TOKEN_CBS_DBG_MEM_WRITE_CRC_RETRY_DDR4 0x0071
#define APCB_TOKEN_CBS_DBG_MEM_WRITE_CRC_ERROR_MAX_REPLAY_DDR4 0x0072
#define APCB_TOKEN_CBS_DBG_MEM_INJECT_TX_CMD_PARITY_ERRORS_DDR4 0x0073
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_DRAM_ECC_SYMBOL_SIZE_DDR4 0x0074
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_DRAM_ECC_EN_DDR4 0x0075
#define APCB_TOKEN_CBS_DBG_MEM_DATA_BUS_CONFIG_CTL_DDR4 0x0076
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_DATA_DRV_STR_DDR4 0x0077
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_RTT_NOM_DDR4 0x0078
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_RTT_WR_DDR4 0x0079
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_RTT_PARK_DDR4 0x007A
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_A_RD_PTR_MP0_CTL_DDR4 0x007B
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_A_RD_PTR_MP0_DDR4 0x007C
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_A_RD_PTR_MP1_CTL_DDR4 0x007D
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_A_RD_PTR_MP1_DDR4 0x007E
#define APCB_TOKEN_CBS_DBG_MEM_DFI_MRL_MARGIN_CTL_DDR4 0x007F
#define APCB_TOKEN_CBS_DBG_MEM_DFI_MRL_MARGIN_DDR4 0x0080
#define APCB_TOKEN_CBS_DBG_MEM_PER_RANK_TIMING_DDR4 0x0081
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_PMU_TRAIN_MODE_DDR4 0x0082
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_MR6_VREF_DQ_CTRL_DDR4 0x0083
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_MR6_VREF_DQ_DDR4 0x0084
#define APCB_TOKEN_CBS_DBG_MEM_VREF_RANGE_DDR4 0x0085
#define APCB_TOKEN_CBS_DBG_CLDO_E12_GA 0x0086
#define APCB_TOKEN_CBS_DBG_CLDO_DDR 0x0087
#define APCB_TOKEN_CBS_DBG_CLDO_WAFL 0x0088
#define APCB_TOKEN_CBS_DBG_CLDO_E12_GB 0x0089
#define APCB_TOKEN_CBS_DBG_CLDO_VDDM0 0x008A
#define APCB_TOKEN_CBS_DBG_CLDO_VDDM1 0x008B
#define APCB_TOKEN_CBS_DBG_CLDO_VDDP_CTL 0x008C
#define APCB_TOKEN_CBS_DBG_CLDOVDD_PVOLTAGE 0x008D
#define APCB_TOKEN_CBS_DBG_CLDO_VDDM_CTL 0x008E
#define APCB_TOKEN_CBS_DBG_CLDOVDD_MVOLTAGE 0x008F
#define APCB_TOKEN_CBS_DBG_CPU_GEN_ABL_BP 0x0090
#define APCB_TOKEN_CBS_DBG_CPU_GEN_ABL_CON_OUT 0x0091
#define APCB_TOKEN_CBS_DBG_MEM_UMC_KEY0_DDR4 0x0092
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_PMU_TRAIN_DFE_DDR4 0x0093
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_PMU_TRAIN_FFE_DDR4 0x0094
#define APCB_TOKEN_CBS_DBG_GNB_DBGU_NBIO_PORT80_TRACING 0x0095
#define APCB_TOKEN_CBS_DBG_GNB_DBGU_NBIO_PORT80_TIMESTAMP 0x0096
#define APCB_TOKEN_CBS_DBG_GNB_RESERVED1 0x0097
#define APCB_TOKEN_CBS_DBG_GNB_RESERVED2 0x0098
#define APCB_TOKEN_CBS_DF_DBG_CAKE_TKN_THRESH 0x0099
#define APCB_TOKEN_CBS_DF_DBG_OPT_CAKE_DAT_LAT 0x009A
#define APCB_TOKEN_CBS_DF_DBG_CPU_MSTR_RCV_PRB_RSP 0x009B
#define APCB_TOKEN_CBS_DF_DBG_IO_MSTR_RCV_PRB_RSP 0x009C
#define APCB_TOKEN_CBS_DBG_CLDO_VDDM 0x009D
#define APCB_TOKEN_CBS_DBG_MEM_PSTATES_DDR4 0x009E
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_POST_PACKAGE_REPAIR_EN_DDR4 0x009F
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_POST_PACKAGE_REPAIR_ALL_BANKS_DDR4 0x00A0
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_POST_PACKAGE_REPAIR_ALL_RANKS_DDR4 0x00A1
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TRDRD_SC_L_DDR4 0x00A2
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TWRWR_SC_L_DDR4 0x00A3
#define APCB_TOKEN_CBS_DBG_MEM_TIMING_TCWL_DDR4 0x00A4
#define APCB_TOKEN_CBS_DBG_CPU_GEN_ABL_HDT_OUT 0x00A5
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_PMU_DELAY_WEIGHT2_D_CTRL_DDR4 0x00A6
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_PMU_DELAY_WEIGHT2_D_DDR4 0x00A7
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_PMU_VOLTAGE_WEIGHT2_D_CTRL_DDR4 0x00A8
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_PMU_VOLTAGE_WEIGHT2_D_DDR4 0x00A9
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_PMU_BITS_PER_POINT_CTRL_DDR4 0x00AA
#define APCB_TOKEN_CBS_DBG_MEM_CTRLLER_PMU_BITS_PER_POINT_DDR4 0x00AB
#define APCB_TOKEN_CBS_DBG_CPU_PM_SC_THROTTLE 0x00AC
#define APCB_TOKEN_CBS_DBG_CPU_PM_SC_THROTTLE_CTRL 0x00AD
#define APCB_TOKEN_CBS_DBG_CPU_GEN_ABL_HDT_OUT_DIE_CTRL 0x00AE
#define APCB_TOKEN_CBS_DBG_CPU_GEN_ABL_HDT_OUT_DIE_BIT_MASK 0x00AF
#define APCB_TOKEN_CBS_DBG_END 0x00B0
#define APCB_TOKEN_CBS_DBG_LIMIT 0x1FFF

typedef enum {
  APCB_TIME_POINT_NONE = 0,
  APCB_TIME_POINT_ANY = 1,
  APCB_TIME_POINT_BEFORE_DRAM_INIT,
  APCB_TIME_POINT_AFTER_DRAM_SPD_TIMING_INIT,
  APCB_TIME_POINT_AFTER_DRAM_DATASHEET_TIMING_INIT,
  APCB_TIME_POINT_AFTER_DRAM_PHY_INIT,
  APCB_TIME_POINT_AFTER_DRAM_INIT,
  APCB_TIME_POINT_BEFORE_PMU_TRAINING,
  APCB_TIME_POINT_AFTER_PMU_TRAINING,
  APCB_TIME_POINT_AFTER_DRAM_FINALIZATION,
  APCB_TIME_POINT_BEFORE_GMI_TRAINING,
  APCB_TIME_POINT_AFTER_GMI_TRAINING,
  APCB_TIME_POINT_AFTER_DF_FINAL_INIT,
  APCB_TIME_POINT_BEFORE_DF_SPF_INIT,
  APCB_TIME_POINT_BEFORE_DF_CREDIT_RELEASE,
  APCB_TIME_POINT_END
} APCB_TIME_POINT;

typedef struct {
  UINT32                TimePoint:8;  ///< Specify when the parameter can be retrieved
  UINT32                Token:13;
  UINT32                Size:3;       ///< The actual size of the parameter - 1
  UINT32                Reserved:8;
} APCB_PARAM_ATTRIBUTE;

typedef struct {
  UINT8                 *BaseAddr;   ///< Pointers to the value stream
} APCB_PARAM_BASE_ADDRESS;

typedef struct {
  UINT8                 Valid:1;      ///< Indicator if the map entry is valid
  UINT8                 Size:3;
  UINT8                 Reserved:4;
  UINT8                 TimePoint;
  UINT16                Offset;       ///< Offset to the parameter
                                      ///< within the APCB parameter block
} APCB_PARAM_MAP;

typedef struct {
  UINT16                ApcbTokenConfig;      ///< The APCB Config Token to be linked
  UINT16                ApcbTokenCbs;         ///< The APCB CBS Token to be linked
} APCB_LINKED_TOKENS;

///===============================================================================
/// Mempory Overclock configuration
#define MEM_OC_SAFE_BOOT_CONTROL_METHOD_DIS  0      ///< Safe Boot is disabled
#define MEM_OC_SAFE_BOOT_CONTROL_METHOD_S5   1      ///< Safe Boot is applied only when S5 power is lost

typedef struct _MEM_OC_SAFE_BOOT_CONTROL_INDEX_IO_STRUCT {
  UINT32                          Size;
  UINT8                           Method;
  UINT8                           IndexPort;    ///< 72
  UINT8                           DataPort;     ///< 73
  UINT8                           Address;      ///< 0x04
  UINT8                           UnlockValue;  ///< 0x55
  UINT8                           LockValue;    ///< 0xAA
} MEM_OC_SAFE_BOOT_CONTROL_INDEX_IO_STRUCT;

typedef struct _MEM_OC_CONFIG_STRUCT {
  UINT32                                    Size;
  MEM_OC_SAFE_BOOT_CONTROL_INDEX_IO_STRUCT  SafeBootCtrlIndexIo;
} MEM_OC_CONFIG_STRUCT;

///===============================================================================
/// DDR4 DIMM ID information
typedef struct {
  UINT8  Socket;            ///< Indicates the socket number
  UINT8  Channel;           ///< Indicates the channel number
  UINT8  Dimm;              ///< Indicates the channel number
  BOOLEAN DimmPresentInConfig;  ///< Indicates that the DIMM config is present
  UINT16 PrevPage1SpdChecksumLow;       ///< DIMM checksum for lower 128 bytes
  UINT16 PrevPage1SpdChecksumHigh;       ///< DIMM checksum for Page 1 upper 128 bytes
  UINT16 PrevDimmManId;     ///< DIMM manufacturer ID
  UINT16 PrevDimmModId;       ///< DIMM Module ID
} DIMM_APCB_INFO_CONFIG_ID;

///
/// Memory Board Layout Info
///
#define MEMORY_LAYOUT_TYPE_DIMM           1
#define MEMORY_LAYOUT_TYPE_ONBOARD        2

//-----------------------------------------------------------------------------
///
/// SPD Data for each DIMM.
///
typedef struct _DIMM_INFO {
  UINT8  DimmSlotPresent;     ///< Indicates that the DIMM is present and Data is valid
  UINT8  SocketId;            ///< Indicates the socket number
  UINT8  ChannelId;           ///< Indicates the channel number
  UINT8  DimmId;              ///< Indicates the channel number
  UINT8  DimmSmbusAdderess;   ///< SMBus address of the DRAM
  UINT8  I2CMuxAddress;       ///< I2C Mux Address
  UINT8  MuxControlAddress;
  UINT8  MuxChannel;          ///< I2C Mux Channel assocaited iwth this SPD
} DIMM_INFO_SMBUS;

 //-----
  // DDR
 //-----

/// DDR4 Data Bus configuration for ZP+
typedef struct {
  UINT32 DimmPerCh;   ///< Bitmap of Dimm slot per chanel
  UINT32 DDRrate;    ///< Bitmap of DDR rate
  UINT32 VDDIO;       ///< Bitmap of VDDIO
  UINT32 Dimm0;       ///< Bitmap of rank type of Dimm0
  UINT32 Dimm1;       ///< Bitmap of rank type of Dimm1

  UINT32 RttNom;      ///< Rtt_Nom
  UINT32 RttWr;       ///< Rtt_Wr
  UINT32 DqStrength;  ///< Data drive strength
  UINT32 DqsStrength; ///< DQS drive strength
  UINT32 OdtStrength; ///< ODT drive strength
} PSCFG_DATABUS_ENTRY;

///===============================================================================
/// _PSP_PS_SODIMM_DDR_STRUCT
/// This data structure is used to pass wrapper parameters to the memory configuration code
///
#define OdtPatSize 5
#define CadBusSODIMMSize 30
#define DataBusSODIMMSize 30
#define MaxFreqSODIMMFM2r2Size 7
typedef struct _PSP_PS_SODIMM_DDR_STRUCT {
  PSCFG_2D_ODTPAT_ENTRY OdtPat[OdtPatSize];
  PSC_TBL_ENTRY OdtPatTblEnt;
  PSCFG_CADBUS_ENTRY ROMDATA CadBusSODIMM[CadBusSODIMMSize];
  PSC_TBL_ENTRY CadBusTblEnSO;
  PSCFG_DATABUS_ENTRY ROMDATA DataBusSODIMM[DataBusSODIMMSize];
  PSC_TBL_ENTRY DataBusTblEnSO;
  PSCFG_MAXFREQ_ENTRY ROMDATA MaxFreqSODIMMFM2r2[MaxFreqSODIMMFM2r2Size];
  PSC_TBL_ENTRY MaxFreqTblEntSOFM2r2;
} PSP_PS_SODIMM_DDR_STRUCT;
///===============================================================================
/// _PSP_PS_UDIMM_DDR_STRUCT
/// This data structure is used to pass wrapper parameters to the memory configuration code
///
#define CadBusUDIMMSize 30
#define DataBusUDIMMSize 30
#define MaxFreqUDIMMFM2r2Size 7
typedef struct _PSP_PS_UDIMM_DDR_STRUCT {
  //-----------------------------------------
  // Platform Specific Data Block
  //-----------------------------------------
  PSCFG_2D_ODTPAT_ENTRY OdtPat[OdtPatSize];
  PSC_TBL_ENTRY OdtPatTblEnt;
  PSCFG_CADBUS_ENTRY ROMDATA CadBusUDIMM[CadBusUDIMMSize];
  PSC_TBL_ENTRY CadBusTblEnU;
  PSCFG_DATABUS_ENTRY ROMDATA DataBusUDIMM[DataBusUDIMMSize];
  PSC_TBL_ENTRY DataBusTblEnU;
  PSCFG_MAXFREQ_ENTRY ROMDATA MaxFreqUDIMMFM2r2[MaxFreqUDIMMFM2r2Size];
  PSC_TBL_ENTRY MaxFreqTblEntUFM2r2;
} PSP_PS_UDIMM_DDR_STRUCT;
///===============================================================================
/// _PSP_PS_DRAMDOWN_DDR_STRUCT
/// This data structure is used to pass wrapper parameters to the memory configuration code
///
#define CadBusDRAMDIMMSize 1
#define DataBusDRAMDIMMSize 1
#define MaxFreqDRAMFM2r2Size 7
typedef struct _PSP_PS_DRAMDOWN_DDR_STRUCT {
  //-----------------------------------------
  // Platform Specific Data Block
  //-----------------------------------------
  PSCFG_2D_ODTPAT_ENTRY OdtPat[OdtPatSize];
  PSC_TBL_ENTRY OdtPatTblEnt;
  PSCFG_CADBUS_ENTRY ROMDATA CadBusDRAMDIMM[CadBusDRAMDIMMSize];
  PSC_TBL_ENTRY CadBusTblEn;
  PSCFG_DATABUS_ENTRY ROMDATA DataBusDRAMDIMM[DataBusDRAMDIMMSize];
  PSC_TBL_ENTRY DataBusTblEn;
  PSCFG_MAXFREQ_ENTRY ROMDATA MaxFreqDRAMFM2r2[MaxFreqDRAMFM2r2Size];
  PSC_TBL_ENTRY MaxFreqTblEntDFM2r2;
} PSP_PS_DRAMDOWN_DDR_STRUCT;


///===============================================================================
/// _PSP_PSC_DRAMDOWN_STRUCT
/// This data structure is used to pass wrapper parameters to the memory configuration code
///
typedef struct _PSP_PSO_STRUCT {
  PSO_ENTRY MemClkDisMap[MEMCLK_DIS_MAP_SIZE];
  PSO_ENTRY CkeTriMap[CKE_TRI_MAP_SIZE];
  PSO_ENTRY OdtTriMap[ODT_TRI_MAP_SIZE];
  PSO_ENTRY CsTriMap[CS_TRI_MAP_SIZE];
  PSO_ENTRY NumberDimmSupported[NUMBER_OF_DIMMS_SUPPORTED_SIZE];
  PSO_ENTRY NumberSolderedDownDimmsSupported[NUMBER_OF_SOLDERED_DOWN_DIMMS_SUPPORTED_SIZE];
  PSO_ENTRY NumberChipSelectsSupported[NUMBER_OF_CHIP_SELECTS_SUPPORTED_SIZE];
  PSO_ENTRY NumberChannelsSupported[NUMBER_OF_CHANNELS_SUPPORTED_SIZE];
  PSO_ENTRY OverrideBusSpeed[OVERRIDE_DDR_BUS_SPEED_SIZE];
  PSO_ENTRY DramTechnology[DRAM_TECHNOLOGY_SIZE];
  PSO_ENTRY SolderedDownSoDimmType[SOLDERED_DOWN_SODIMM_TYPE_SIZE];
  PSO_ENTRY MemoryPowerPolicyOverride[MEMORY_POWER_POLICY_OVERRIDE_SIZE];
  PSO_ENTRY MotherboardLayers[MOTHER_BOARD_LAYERS_SIZE];
} PSP_PSO_STRUCT;
///===============================================================================
/// _PSP_SPD_LPDDR3_STRUCT
/// This data structure is used to pass wrapper parameters to the memory configuration code
///
typedef struct _PSP_SPD_STRUCT {
   UINT32 TotalDimms;
  SPD_DEF_STRUCT  SpdData[APCB_TOTAL_SYSTEM_DIMMS];
} PSP_SPD_STRUCT;

/// ABL Console Out Header.
typedef struct _ABL_CONSOLE_OUT_HEADER {
  BOOLEAN AblConsoleEnable;                     ///< Enable ABL Console output
                                                ///< TRUE - Enable ABL console output  (Default)
                                                ///< FALSE - Disable ABL console output
  UINT32  AblConsolePort;                       ///< 32 bit ABL Console output port (Default - 0x80)
  BOOLEAN AblConsoleFilterMemFlowEnable;        ///< ABL Console out filter for "MEM FLOW"    (Default - Enabled)
                                                ///< TRUE - Filter is enabled  (Default)
                                                ///< FALSE - Fitler is diesabed
  BOOLEAN AblConsoleFilterMemSetRegEnable;      ///< ABL Console out filter to enable "MEM SETREG" (Default - Enabled)
                                                ///< TRUE - Filter is enabled  (Default)
                                                ///< FALSE - Fitler is diesabed
  BOOLEAN AblConsoleFilterMemGetRegEnable;      ///< ABL Console out filter to enable "MEM GETREG"   (Default - disabled)
                                                ///< TRUE - Filter is enabled
                                                ///< FALSE - Fitler is diesabed (Default)
  BOOLEAN AblConsoleFilterMemStatusEnable;      ///< ABL Console out filter to enable "MEM STATUS"   (Default - disabled)
                                                ///< TRUE - Filter is enabled
                                                ///< FALSE - Fitler is diesabed (Default)
  BOOLEAN AblConsoleFilterMemPmuEnable;         ///< ABL Console out filter to enable "MEM PMU"   (Default - disabled)
                                                ///< TRUE - Filter is enabled
                                                ///< FALSE - Fitler is diesabed (Default)
  BOOLEAN AblConsoleFilterMemPmuSramReadEnable; ///< ABL Console out filter to enable "MEM PMU SRAM READ" (Default - disabled)
                                                ///< TRUE - Filter is enabled
                                                ///< FALSE - Fitler is diesabed (Default)
  BOOLEAN AblConsoleFilterMemPmuSramWriteEnable; ///< ABL Console out filter to enable "MEM PMU SRAM WRITE" (Default - disabled)
                                                 ///< TRUE - Filter is enabled
                                                 ///< FALSE - Fitler is diesabed (Default)
  BOOLEAN AblConsoleFilterMemTestVerboseEnable; ///< ABL Console out filter to enable "MEM TEST VERBOSE" (Default - disabled)
                                                ///< TRUE - Filter is enabled
                                                ///< FALSE - Fitler is diesabed (Default)
} ABL_CONSOLE_OUT_HEADER;

/// Breakpoint control
typedef struct _ABL_BREAKPOINT_CONTROL {
  BOOLEAN BreakPointEnable;      ///< Enable ABL Console output
                                 ///< TRUE - All dies will stop at the same breakpoints (Default)
                                 ///< FALSE - Master will only stop with breakpoints
  BOOLEAN BreakOnAllDies;        ///< Enable ABL Console output
                                 ///< TRUE - All dies will stop at the same breakpoints  (Default)
                                 ///< FALSE - Master will only stop with breakpoints
} ABL_BREAKPOINT_CONTROL;

///===============================================================================
/// PSP_CONSOLE_OUT_STRUCT
/// This data structure is used to control console output support
///
typedef struct _PSP_CONSOLE_OUT_STRUCT {
  ABL_CONSOLE_OUT_HEADER  ConsoleOutControl;    //< Control structure for Console out
  ABL_BREAKPOINT_CONTROL  BreakPointControl;    //< Control structure for Breakpoints
} PSP_CONSOLE_OUT_STRUCT;

///===============================================================================
/// PSP_EVENT_OUT_CONTROL_STRUCT
/// This data structure is used to control sending AGESA Event info to the specified port
///
typedef struct PSP_ERROR_OUT_CONTROL_STRUCT {
  IN
  BOOLEAN EVENT_OUT_PORT_ENABLED; ///< Indicates if AGESA PSP will output Event Info to specificed port
  IN
  BOOLEAN HALT_ON_CRITICAL_FATAL_EVENT_ENABLED; ///< Indicates if AGESA PSP will halt on critical/fatal event
  IN
  UINT64  EventInfoPort;    //< Port to output AGESA Event Info
} PSP_EVENT_OUT_CONTROL_STRUCT;

///===============================================================================
/// ERROR_ABL_GPIO
/// This data structure is user-defined GPIO indicator of a failure
///
typedef struct _ERROR_ABL_GPIO {
  UINT8     Gpio;          ///< FCH GPIO number of failure indicator
  UINT8     GpioIoMUX;     ///< Value write to IOMUX to configure this GPIO pin
  UINT8     GpioBankCtl;   ///< Value write to GPIOBankCtl[23:16] to configure this GPIO pin
} ERROR_ABL_GPIO;

///===============================================================================
/// ERROR_BEEP_CODE_TABLE
/// This data structure can be customized/enhanced as per platform need
///
#define BEEP_ERROR_TYPE_MASK       0xF000
#define BEEP_ERROR_OPERATION_MASK  0x0FFF
#define BEEP_ERROR_TYPE_GENERAL    0x3000
#define BEEP_ERROR_TYPE_MEMORY     0x4000
#define BEEP_ERROR_TYPE_DF         0x5000
#define BEEP_ERROR_TYPE_CCX        0x6000
#define BEEP_ERROR_TYPE_GNB        0x7000
#define BEEP_ERROR_TYPE_PSP        0x8000
#define BEEP_ERROR_TYPE_SMU        0x9000
#define BEEP_ERROR_TYPE_UNKNOW     0xFFFF
#define BEEP_ERROR_TABLE_SIZE      8

// PEAK_ATTR attribute
typedef union {
  struct {
    UINT32  PeakCnt:5;        ///< number of valid bit, zeor based
    UINT32  PulseWidths:3;    ///< pulse widths of positive peak, multiple of 0.1s
    UINT32  RepeatCnt:4;      ///< waves repeat count
    UINT32  :20;              ///< Reserved
  } Bits;
  UINT32  Uint32;
} PEAK_ATTR;

///===============================================================================
/// MEMORY OVERCLOCK ERROR TYPE
///
#define ABL_MEM_OVERCLOCK_ERROR_RRW_TEST       0x4024
#define ABL_MEM_OVERCLOCK_ERROR_PMU_TRAINING   0x4025
#define ABL_MEM_OVERCLOCK_ERROR_MEM_INIT       0x4026
#define ABL_MEM_OVERCLOCK_ERROR_MEM_OTHER      0x4027

typedef struct _ERROR_BEEP_CODE_TABLE {
  UINT16    ErrorType;     ///< Error type is specified for the beep codes
  UINT16    PeakMap;       ///< Peak bitmap value to indicated the error
  UINT32    WA32;          ///
} ERROR_BEEP_CODE_TABLE;

///===============================================================================
/// PSP_ERROR_OUT_CONTROL_STRUCT
/// This data structure is used to control sending AGESA Event info to the specified port
///
typedef struct _PSP_ERROR_OUT_CONTROL_STRUCT {
  IN
  BOOLEAN ErrorLogPortReportingEnable;         ///< Indicates if ABL will report errors via a port
                                               ///< TRUE - Error logging will be reported via a port
                                               ///< FALSE - Error logging will not be reported via a port
  IN
  BOOLEAN ErrorReportErrorGpioEnable;          ///< Indicates if ABL will report errors via GPIO
                                               ///< TRUE - Error logging will be reported via a GPIO
                                               ///< FALSE - Error logging will not be reported via a GPIO
                                               ///< (only valid if ErrorLogPortReportingEnable = TRUE)
  IN
  BOOLEAN ErrorReportErrorBeepCodeEnable;      ///< This flag indicates if the ABL will report error via beep codes
                                               ///< TRUE - Error logging will be reported via FCH speaker
                                               ///< FALSE - Error logging will not be reported via FCH speaker
                                               ///< (only valid if ErrorLogPortReportingEnable = TRUE)
  IN
  BOOLEAN ErrorLogReportUsingHandshakeEnable;  ///< This flag indicates if the ABL will use an handshake for the Error Log
                                               ///< TRUE - Error log reported using a handshake with the "ErrorLogOutputPort" and "ErrorLogInputPort"
                                               ///< FALSE - Error log reported using "ErrorLogOutputPort" only with each DWORD in log delayed by
                                               ///<         ErrorLogOutputDwordDelay
  IN
  UINT32  ErrorLogInputPort;                   ///< Input Port to receive ABL Error information
                                               ///<  (only valid if ReportErrorLogUsingHandshakeEnable = TRUE)
  IN
  UINT32  ErrorLogOutputDwordDelay;            ///< Number of "10ns" to wait before sending the next Log Dword informaiton via "ErrorLogOutputPort"
                                               ///< (only valid if ReportErrorLogUsingHandshakeEnable = FALSE)
  IN
  UINT32  ErrorLogOutputPort;                  ///< Output Port for ABL Error information
  IN
  BOOLEAN  ErrorStopOnFirstFatalErrorEnable;   ///< Indicates that ABL will stop on the first fatal error
                                               ///< TRUE - Stop and report the first FATAL error
                                               ///< FALSE - Report all errors
  IN
  UINT32  ErrorLogReportInputPortSize;          ///< Indicates the sie of the input and outut port
                                                ///< 1 - 8 bit port
                                                ///< 2 - 16 bit port
                                                ///< 4 - 32 bit port
  IN
  UINT32  ErrorLogReportOutputPortSize;         ///< Indicates the sie of the input and outut port
                                                ///< 1 - 8 bit port
                                                ///< 2 - 16 bit port
                                                ///< 4 - 32 bit port
  IN
  UINT32  ErrorLogReportInputPortType;          ///< Indicates the type of Input Port or location of the port
                                                ///< 0 - PCIE HT0
                                                ///< 2 - PCIE HT1
                                                ///< 5 - PCIE MMIO
                                                ///< 6 - FCH_HT_IO (Default)
                                                ///< 7 - FCH_MMIO
  IN
  UINT32  ErrorLogReportOutputPortType;          ///< Indicates the type of Output Port or location of the port
                                                ///< 0 - PCIE HT0
                                                ///< 2 - PCIE HT1
                                                ///< 5 - PCIE MMIO
                                                ///< 6 - FCH_HT_IO (Default)
                                                ///< 7 - FCH_MMIO

  IN
  BOOLEAN  ErrorLogReportClearAcknowledgement;   ///< Indicates if the ABL will clear acknolgements during protocol
                                                 ///< TRUE - Clear acknowledgemetns
                                                 ///< FALSE - Do not clear acknologements

  ERROR_ABL_GPIO   ErrorLogReportGpioReport;     ///< Structure for the GPIO definition
                                                 ///< (only valid if ErrorReportErrorGpioEnable = TRUE)

  ERROR_BEEP_CODE_TABLE  BeepCodeTable[BEEP_ERROR_TABLE_SIZE];        ///< Structure for definition of beep codes
                                                                      ///< (only valid if ErrorReportErrorBeepCodeEnable = TRUE)
  IN
  BOOLEAN ErrorLogHeartBeatEnable;             ///< Indicates if ABL will provide periodic status to a port as a heart beat
                                               ///< TRUE - Heartbeat Error log will be reported via a port
                                               ///< FALSE - Heartbeat Error log will not be reported via a port
                                               ///<
                                               ///< Notes:
                                               ///<   1) This feature is only valid if ErrorLogPortReportingEnable
                                               ///<   2) This is can be mono-directional or bi-directional based on "ErrorLogReportUsingHandshakeEnable"
                                               ///<        "ErrorLogReportUsingHandshakeEnable" = TRUE - bi-directional
                                               ///<        "ErrorLogReportUsingHandshakeEnable" = FALSE - mono-directional
                                               ///<   3) Requires the following to be defined:
                                               ///<    - "ErrorLogReportInputPortType", "ErrorLogInputPort, "ErrorLogReportInputPortSize"
                                               ///<    - "ErrorLogReportInputPortType", "ErrorLogInputPort, "ErrorLogReportInputPortSize"
} PSP_ERROR_OUT_CONTROL_STRUCT;

///===============================================================================
/// PSP_EXT_VOLTAGE_CONTROL_STRUCT
/// This data structure is used to control sending AGESA volatage info to the specified port
///
typedef struct _PSP_EXT_VOLTAGE_CONTROL_STRUCT {
  IN
  BOOLEAN ExtVoltageControlEnable;             ///< Indicates if ABL will supprot external voltage changes
                                               ///< TRUE - External voltage change are supported
                                               ///< FALSE - No external voltage change are supported (Default)
  IN
  UINT32  ExtVoltageInputPort;                 ///< Input Port to receive voltage information  (Default = 0x84)
  IN
  UINT32  ExtVoltageOutputPort;                ///< Output Port to send voltage (Default = 0x80)
  IN
  UINT32  ExtVoltageInputPortSize;             ///< Indicates the sie of the input and outut port
                                               ///< 1 - 8 bit port
                                               ///< 2 - 16 bit port
                                               ///< 4 - 32 bit port (Default)
  IN
  UINT32  ExtVoltageOutputPortSize;            ///< Indicates the sie of the input and outut port
                                               ///< 1 - 8 bit port
                                               ///< 2 - 16 bit port
                                               ///< 4 - 32 bit port (Default)
  IN
  UINT32  ExtVoltageInputPortType;              ///< Indicates the type of Input Port or location of the port
                                                ///< 0 - PCIE HT0
                                                ///< 2 - PCIE HT1
                                                ///< 5 - PCIE MMIO
                                                ///< 6 - FCH_HT_IO (Default)
                                                ///< 7 - FCH_MMIO
  IN
  UINT32  ExtVoltageOutputPortType;             ///< Indicates the type of Output Port or location of the port
                                                ///< 0 - PCIE HT0
                                                ///< 2 - PCIE HT1
                                                ///< 5 - PCIE MMIO
                                                ///< 6 - FCH_HT_IO (Default)
                                                ///< 7 - FCH_MMIO

  IN
  BOOLEAN  ExtVoltageClearAcknowledgement;     ///< Indicates if the ABL will clear acknolgements during protocol
                                               ///< TRUE - Clear acknowledgemetns (Default)
                                               ///< FALSE - Do not clear acknologements
} PSP_EXT_VOLTAGE_CONTROL_STRUCT;


//APCB HEADER
//#define APCB_HEADER_VERSION_MAJOR   2
//#define APCB_HEADER_VERSION_MINOR   0
//#define APCB_HEADER_VERSION         ((APCB_HEADER_VERSION_MAJOR << 4) | APCB_HEADER_VERSION_MINOR)

//
// APCB Header Definition Version 2
//
typedef struct {
  UINT32  Signature;          // ASCII "APCB", 'A' is LSB
  UINT16  SizeOfHeader;       // Size of header
  UINT16  Version;            // Version, BCD. Version 1.2 is 0x12
  UINT32  SizeOfApcb;         // Size of APCB
  UINT32  UniqueApcbInstance; // UniqueApcbInstance to ensure
                              // compatibitly for giveen flshed BIOS lifecycle
  UINT8   CheckSumByte;        // APCB Checksum Byte
  UINT8   Reserved1[3];        // Reserved
  UINT32  Reserved2[3];        // Reserved
} APCB_HEADER;


#define APCB_INDEX_HEADER_VERSION_MAJOR   0
#define APCB_INDEX_HEADER_VERSION_MINOR   1
#define APCB_INDEX_HEADER_VERSION         ((APCB_INDEX_HEADER_VERSION_MAJOR << 4) | APCB_INDEX_HEADER_VERSION_MINOR)
//
// APCB Index of Data Type Header Definition
//
typedef struct {
  UINT16  SizeOfHeader;     // Size of header
  UINT16  Version;          // Version, BCD. Version 1.2 is 0x12
  UINT16  Reserved;         // Reserved
  UINT32  SizeOfIndexData;  // Size of index data, absolute address in PSP
                            // NOTE: Will we support it to be relative address to starging address of APCB?
} APCB_INDEX_HEADER;

//
// APCB Index of Data Type  Definition
//
typedef struct {
  UINT16  GroupId;          // Group ID
  UINT16  TypeId;           // Type ID
  UINT32  Address;          // Data address
} APCB_TYPE_INDEX;

//
// APCB Data Type Header Definition
//
typedef struct {
  UINT16  GroupId;          // Group ID
  UINT16  TypeId;           // Type ID
  UINT16  SizeOfType;       // Size of type, in bytes
  UINT16  InstanceId;       // Instance ID
  UINT32  Reserved1;
  UINT32  Reserved2;
} APCB_TYPE_HEADER;

#define ALIGN_SIZE_OF_TYPE    4


#define APCB_GROUP_HEADER_VERSION_MAJOR   0
#define APCB_GROUP_HEADER_VERSION_MINOR   1
#define APCB_GROUP_HEADER_VERSION         ((APCB_GROUP_HEADER_VERSION_MAJOR << 4) | APCB_GROUP_HEADER_VERSION_MINOR)

#define INVALID_GROUP_ID    0xFFFF
#define UNKNOWN_GROUP_ID    0xFFFE

#define OVERRIDE_INSTANCE 0x10000
#define INSTANCE_ID_MASK 0xFFFF

//
// APCB Data Group Header Definition
//
typedef struct {
  UINT32  Signature;        // ASCII Signature
  UINT16  GroupId;          // Group ID
  UINT16  SizeOfHeader;     // Size of header
  UINT16  Version;          // Version, BCD. Version 1.2 is 0x12
  UINT16  Reserved;         // Reserved
  UINT32  SizeOfGroup;      // Size of group
} APCB_GROUP_HEADER;

///===============================================================================
// Get board ID retrieve method, then load the APCB instance based on the board ID


#define BOARD_ID_METHOD_SMBUS     1
#define BOARD_ID_METHOD_EEPROM    2
#define BOARD_ID_METHOD_GPIO      3
#define BOARD_ID_METHOD_IO        4
#define METHOD_USER_CONFIG        0xF

#define ID_FEATURE_MASK           0x80   // This is Bit 7 of

typedef struct {
  IN       UINT8    IdAndFeatureMask;    ///< Mask to the value read from board ID register
                                         ///< Bit 6:0 - Id Mask Bits
                                         ///< Bit7 - detemines between normal or feature controlled Instance
                                         ///< Bit7,   1 = User Controlled Feature Enabled, 0 - Normal Mode
  IN       UINT8    IdAndFeatureValue;   ///< IdValue after mask
  IN       UINT8    ApcbInstance;        ///< The corresponding APCB instance
} ID_APCB_MAPPING;

/// For IO method
typedef struct _PSP_GET_BOARD_ID_FROM_IO_STRUCT {
  IN       UINT16 AccessMethod; ///< 0: EEPROM, 1: Smbus, 2: FCH GPIO, 4: IO, 0xF: USER_CONFIG
  IN       UINT16 ConfigPortWidth; ///< Width of Config Port
  IN       UINT16 ConfigValue; ///< Value write to Configure IO Port for accessing the data
  IN       UINT32 ConfigPortAddress; ///< ConfigPort Address
  IN       UINT16 DataPortWidth; ///< DataPort Width
  IN       UINT32 DataPortAddress; ///< Data Port Address
  IN       ID_APCB_MAPPING IdApcbMapping[];
} PSP_GET_BOARD_ID_FROM_IO_STRUCT;

/// For EEPROM method
typedef struct _PSP_GET_BOARD_ID_FROM_EEPROM_STRUCT {
  IN       UINT16   AccessMethod;   ///< 0: EEPROM, 1: Smbus, 2: FCH GPIO. 0xF: USER_CONFIG
  IN       UINT16   I2cCtrlr;       ///< ZP I2C controller: 0: I2C_0, 1: I2C_1, 2: I2C_2, 3: I2C_3, 4: I2C_4, 5: I2C_5                                   ///
  IN       UINT16   SmbusAddr;      ///< Smbus address of the EEPROM
} PSP_GET_BOARD_ID_FROM_EEPROM_STRUCT;

/// For Smbus device method
typedef struct _PSP_GET_BOARD_ID_FROM_SMBUS_STRUCT {
  IN       UINT16   AccessMethod;   ///< 0: EEPROM, 1: Smbus, 2: FCH GPIO F: None
  IN       UINT16   I2cCtrlr;       ///< ZP I2C controller: 0: I2C_0, 1: I2C_1, 2: I2C_2, 3: I2C_3, 4: I2C_4, 5: I2C_5                                   ///
  IN       UINT16   SmbusAddr;      ///< Smbus address of the device to get the board ID
  IN       UINT16   RegIndex;       ///< Register index of the Smbus device to get the board ID
  IN       ID_APCB_MAPPING   IdApcbMapping[];
} PSP_GET_BOARD_ID_FROM_SMBUS_STRUCT;

/// For FCH GPIO method
typedef struct _PSP_GET_BOARD_ID_FROM_GPIO_STRUCT {
  IN       UINT16   AccessMethod;   ///< 0: EEPROM, 1: Smbus, 2: FCH GPIO, 0xF: USER_CONFIG
  IN       UINT8    Gpio0;          ///< FCH GPIO number of the board ID bit 0
  IN       UINT8    Gpio0IoMUX;     ///< Value write to IOMUX to configure this GPIO pin
  IN       UINT8    Gpio0BankCtl;   ///< Value write to GPIOBankCtl[23:16] to configure this GPIO pin
  IN       UINT8    Gpio1;          ///< FCH GPIO number of the board ID bit 1
  IN       UINT8    Gpio1IoMUX;     ///< Value write to IOMUX to configure this GPIO pin
  IN       UINT8    Gpio1BankCtl;   ///< Value write to GPIOBankCtl[23:16] to configure this GPIO pin
  IN       UINT8    Gpio2;          ///< FCH GPIO number of the board ID bit 2, put 0xff if does not exist
  IN       UINT8    Gpio2IoMUX;     ///< Value write to IOMUX to configure this GPIO pin
  IN       UINT8    Gpio2BankCtl;   ///< Value write to GPIOBankCtl[23:16] to configure this GPIO pin
  IN       UINT8    Gpio3;          ///< FCH GPIO number of the board ID bit 3, put 0xff if does not exist
  IN       UINT8    Gpio3IoMUX;     ///< Value write to IOMUX to configure this GPIO pin
  IN       UINT8    Gpio3BankCtl;   ///< Value write to GPIOBankCtl[23:16] to configure this GPIO pin
  IN       ID_APCB_MAPPING   IdApcbMapping[];
} PSP_GET_BOARD_ID_FROM_GPIO_STRUCT;

/// For User Controlled Method to Load Specific APCB Instance
typedef struct _PSP_METHOD_USER_CONTROLLED_FEATURE_STRUCT {
  IN       UINT16   AccessMethod;           ///< 0: EEPROM, 1: Smbus, 2: FCH GPIO,  0xF: USER_CONFIG
  IN       UINT16   FeatureMaskData;        ///< Data Pattern defined by user which can be used to
                                            ///< mask between normal and feature enabled Instance selection
  IN       ID_APCB_MAPPING   IdApcbMapping[];
} PSP_METHOD_USER_CONTROLLED_FEATURE_STRUCT;

//
// XGMI TX EQ definitions
//
#define XGMI_BIT_POS(Position)                  (1 << Position)

// NOTE: Bit28~31 are used as NodeType in common.
#define XGMI_TX_EQ_COMMON_NODE_TYPE_SHIFT       28
#define XGMI_TX_EQ_COMMON_NODE_TYPE_SIZE_MASK   0x0F
#define XGMI_TX_EQ_COMMON_NODE_TYPE_MASK        (XGMI_TX_EQ_COMMON_NODE_TYPE_SIZE_MASK << XGMI_TX_EQ_COMMON_NODE_TYPE_SHIFT)
// Shared node type definitions
#define   XGMI_TX_EQ_NODE_TYPE_RSVD             0x0
#define   XGMI_TX_EQ_NODE_TYPE_DATA             0x1
#define   XGMI_TX_EQ_NODE_TYPE_LOC              0x2
#define   XGMI_TX_EQ_NODE_TYPE_FREQ             0x3
#define   XGMI_TX_EQ_NODE_TYPE_FREQ_TBL         0x4
#define   XGMI_TX_EQ_NODE_TYPE_FREQ_END         0x5
#define   XGMI_TX_EQ_NODE_TYPE_END              0xF

// XGMI_TX_EQ MAKE_TX_EQ_FREQ_TABLE attribute
typedef struct _XGMI_TX_EQ_COMMON {
  UINT32  :24;                                   ///< Reserved
  UINT32  :4;                                    ///< Reserved
  UINT32  NodeType:4;                            ///< Node type
} XGMI_TX_EQ_COMMON;

#define XGMI_TX_EQ_FREQ_SPEED_MASK_SHIFT        0
#define XGMI_TX_EQ_FREQ_SPEED_MASK_SIZE_MASK    0xFF
#define XGMI_TX_EQ_FREQ_SPEED_MASK_MASK         (XGMI_TX_EQ_FREQ_SPEED_MASK_SIZE_MASK << XGMI_TX_EQ_FREQ_SPEED_MASK_SHIFT)
#define   XGMI_TX_EQ_SPEED_53                   XGMI_BIT_POS(0)   // Instance ID of 5.3G
#define   XGMI_TX_EQ_SPEED_64                   XGMI_BIT_POS(1)   // Instance ID of 6.4G
#define   XGMI_TX_EQ_SPEED_75                   XGMI_BIT_POS(2)   // Instance ID of 7.5G
#define   XGMI_TX_EQ_SPEED_85                   XGMI_BIT_POS(3)   // Instance ID of 8.5G
#define   XGMI_TX_EQ_SPEED_96                   XGMI_BIT_POS(4)   // Instance ID of 9.6G
#define   XGMI_TX_EQ_SPEED_107                  XGMI_BIT_POS(5)   // Instance ID of 10.7G
#define   XGMI_TX_EQ_SPEED_117                  XGMI_BIT_POS(6)   // Instance ID of 11.7G
#define   XGMI_TX_EQ_SPEED_128                  XGMI_BIT_POS(7)   // Instance ID of 12.8G
#define   XGMI_TX_EQ_SPEED_ALL                  (XGMI_TX_EQ_SPEED_53 | XGMI_TX_EQ_SPEED_64 | XGMI_TX_EQ_SPEED_75 | XGMI_TX_EQ_SPEED_85 | XGMI_TX_EQ_SPEED_96 | XGMI_TX_EQ_SPEED_107 | XGMI_TX_EQ_SPEED_117 | XGMI_TX_EQ_SPEED_128)

// XGMI_TX_EQ MAKE_TX_EQ_FREQ_TABLE attribute
typedef struct _XGMI_TX_EQ_FREQ {
  UINT32  SpeedMask:8;                          ///< Speed mask
  UINT32  :16;                                  ///< Reserved
  UINT32  :4;                                   ///< Reserved
  UINT32  NodeType:4;                           ///< Node type: MAKE_TX_EQ_FREQ_TABLE
} XGMI_TX_EQ_FREQ;

#define MAKE_TX_EQ_FREQ(SpeedMask)               ((UINT32) (((XGMI_TX_EQ_NODE_TYPE_FREQ & XGMI_TX_EQ_COMMON_NODE_TYPE_SIZE_MASK) << XGMI_TX_EQ_COMMON_NODE_TYPE_SHIFT) | \
                                                                   ((SpeedMask & XGMI_TX_EQ_FREQ_SPEED_MASK_SIZE_MASK) << XGMI_TX_EQ_FREQ_SPEED_MASK_SHIFT)))
#define MAKE_TX_EQ_FREQ_TBL(SpeedMask)           ((UINT32) (((XGMI_TX_EQ_NODE_TYPE_FREQ_TBL & XGMI_TX_EQ_COMMON_NODE_TYPE_SIZE_MASK) << XGMI_TX_EQ_COMMON_NODE_TYPE_SHIFT) | \
                                                                   ((SpeedMask & XGMI_TX_EQ_FREQ_SPEED_MASK_SIZE_MASK) << XGMI_TX_EQ_FREQ_SPEED_MASK_SHIFT)))


#define XGMI_TX_EQ_ATTR_LANE_MASK_SHIFT         0
#define XGMI_TX_EQ_ATTR_LANE_MASK_SIZE_MASK     0xFFFF
#define XGMI_TX_EQ_ATTR_LANE_MASK_MASK          (XGMI_TX_EQ_ATTR_LANE_MASK_SIZE_MASK << XGMI_TX_EQ_ATTR_LANE_MASK_SHIFT)
#define XGMI_TX_EQ_ATTR_DIE_MASK_SHIFT          16
#define XGMI_TX_EQ_ATTR_DIE_MASK_SIZE_MASK      0xFF
#define XGMI_TX_EQ_ATTR_DIE_MASK_MASK           (XGMI_TX_EQ_ATTR_DIE_MASK_SIZE_MASK << XGMI_TX_EQ_ATTR_DIE_MASK_SHIFT)
#define XGMI_TX_EQ_ATTR_SOCKET_MASK_SHIFT       24
#define XGMI_TX_EQ_ATTR_SOCKET_MASK_SIZE_MASK   0x03
#define XGMI_TX_EQ_ATTR_SOCKET_MASK_MASK        (XGMI_TX_EQ_ATTR_SOCKET_MASK_SIZE_MASK << XGMI_TX_EQ_ATTR_SOCKET_MASK_SHIFT)
#define XGMI_TX_EQ_ATTR_DATA_MODE_SHIFT         26
#define XGMI_TX_EQ_ATTR_DATA_MODE_SIZE_MASK     0x03
#define XGMI_TX_EQ_ATTR_DATA_MODE_MASK          (XGMI_TX_EQ_ATTR_DATA_MODE_SIZE_MASK << XGMI_TX_EQ_ATTR_DATA_MODE_SHIFT)
// Data mode definitions
#define   XGMI_TX_EQ_DATA_MODE_PAIR             0        ///< Pair mode, same value for all matched lanes.
#define   XGMI_TX_EQ_DATA_MODE_LIST             1        ///< List mode, list each value for each matched lanes from low to high socket/die/lane.
#define   XGMI_TX_EQ_DATA_MODE_LIST_COMPACT     2        ///< List compact mode, list each value for each matched lanes from low to high socket/die/lane in compact format
#define   XGMI_TX_EQ_DATA_MODE_MAX              3        ///< Maximum data mode
// NOTE: Bit28~31 are used as NodeType in common.

#define XGMI_ALL_SOCKETS                        0x03     ///< 2 sockets per system
#define XGMI_MAX_SOCKET_COUNT                   2
#define XGMI_ALL_DIES                           0x0F     ///< 4 dies per socket
#define XGMI_MAX_DIE_COUNT_PER_SOCKET           4
#define XGMI_ALL_LANES                          0xFFFF   ///< 16 lanes per die
#define XGMI_MAX_LANE_COUNT_PER_DIE             16
#define XGMI_SOCKET0                            XGMI_BIT_POS(0)
#define XGMI_SOCKET1                            XGMI_BIT_POS(1)
#define XGMI_DIE0                               XGMI_BIT_POS(0)
#define XGMI_DIE1                               XGMI_BIT_POS(1)
#define XGMI_DIE2                               XGMI_BIT_POS(2)
#define XGMI_DIE3                               XGMI_BIT_POS(3)
#define XGMI_DIE4                               XGMI_BIT_POS(4)
#define XGMI_DIE5                               XGMI_BIT_POS(5)
#define XGMI_DIE6                               XGMI_BIT_POS(6)
#define XGMI_DIE7                               XGMI_BIT_POS(7)
#define XGMI_LANE0                              XGMI_BIT_POS(0)
#define XGMI_LANE1                              XGMI_BIT_POS(1)
#define XGMI_LANE2                              XGMI_BIT_POS(2)
#define XGMI_LANE3                              XGMI_BIT_POS(3)
#define XGMI_LANE4                              XGMI_BIT_POS(4)
#define XGMI_LANE5                              XGMI_BIT_POS(5)
#define XGMI_LANE6                              XGMI_BIT_POS(6)
#define XGMI_LANE7                              XGMI_BIT_POS(7)
#define XGMI_LANE8                              XGMI_BIT_POS(8)
#define XGMI_LANE9                              XGMI_BIT_POS(9)
#define XGMI_LANE10                             XGMI_BIT_POS(10)
#define XGMI_LANE11                             XGMI_BIT_POS(11)
#define XGMI_LANE12                             XGMI_BIT_POS(12)
#define XGMI_LANE13                             XGMI_BIT_POS(13)
#define XGMI_LANE14                             XGMI_BIT_POS(14)
#define XGMI_LANE15                             XGMI_BIT_POS(15)

// XGMI_TX_EQ apply attribute
typedef struct _XGMI_TX_EQ_ATTR {
  UINT32  LaneMask:16;                           ///< Lane mask per die       (2^4)
  UINT32  DieMask:8;                             ///< Die mask per socket     (2^3)
  UINT32  SocketMask:2;                          ///< Socket mask per system  (2^1)
  UINT32  DataMode:2;                            ///< Data mode. Pair or List
  UINT32  NodeType:4;                            ///< Node type: Location
} XGMI_TX_EQ_ATTR;

#define MAKE_TX_EQ_ATTR(SocketMask, DieMask, LaneMask, DataMode)  ((UINT32) (((XGMI_TX_EQ_NODE_TYPE_LOC & XGMI_TX_EQ_COMMON_NODE_TYPE_SIZE_MASK) << XGMI_TX_EQ_COMMON_NODE_TYPE_SHIFT) | \
                                                                   ((DataMode & XGMI_TX_EQ_ATTR_DATA_MODE_SIZE_MASK) << XGMI_TX_EQ_ATTR_DATA_MODE_SHIFT) | \
                                                                   ((SocketMask & XGMI_TX_EQ_ATTR_SOCKET_MASK_SIZE_MASK) << XGMI_TX_EQ_ATTR_SOCKET_MASK_SHIFT) | \
                                                                   ((DieMask & XGMI_TX_EQ_ATTR_DIE_MASK_SIZE_MASK) << XGMI_TX_EQ_ATTR_DIE_MASK_SHIFT) | \
                                                                   ((LaneMask & XGMI_TX_EQ_ATTR_LANE_MASK_SIZE_MASK) << XGMI_TX_EQ_ATTR_LANE_MASK_SHIFT)))

#define XGMI_TX_EQ_DATA_EQ_PRE_SHIFT            0
#define XGMI_TX_EQ_DATA_EQ_PRE_SIZE_MASK        0x3F
#define XGMI_TX_EQ_DATA_EQ_PRE_MASK             (XGMI_TX_EQ_DATA_EQ_PRE_SIZE_MASK << XGMI_TX_EQ_DATA_EQ_PRE_SHIFT)
#define XGMI_TX_EQ_DATA_EQ_MAIN_SHIFT           8
#define XGMI_TX_EQ_DATA_EQ_MAIN_SIZE_MASK       0x3F
#define XGMI_TX_EQ_DATA_EQ_MAIN_MASK            (XGMI_TX_EQ_DATA_EQ_MAIN_SIZE_MASK << XGMI_TX_EQ_DATA_EQ_MAIN_SHIFT)
#define XGMI_TX_EQ_DATA_EQ_POST_SHIFT           16
#define XGMI_TX_EQ_DATA_EQ_POST_SIZE_MASK       0x3F
#define XGMI_TX_EQ_DATA_EQ_POST_MASK            (XGMI_TX_EQ_DATA_EQ_POST_SIZE_MASK << XGMI_TX_EQ_DATA_EQ_POST_SHIFT)
// NOTE: Bit28~31 are used as NodeType in common.

// XGMI TX EQ settings
typedef struct _XGMI_TX_EQ_DATA {
  UINT32  EqPre:6;                              ///< EQ_PRE/TxCoeffPre
  UINT32  :2;                                   ///< Reserved
  UINT32  EqMain:6;                             ///< EQ_MAIN/TxCoeffCurs
  UINT32  :2;                                   ///< Reserved
  UINT32  EqPost:6;                             ///< EQ_POST/TxCoeffPost
  UINT32  :2;                                   ///< Reserved
  UINT32  :4;                                   ///< Reserved
  UINT32  NodeType:4;                           ///< Node type: Data
} XGMI_TX_EQ_DATA;

#define MAKE_TX_EQ_DATA(EqMain, EqPost, EqPre)          ((UINT32) (((XGMI_TX_EQ_NODE_TYPE_DATA & XGMI_TX_EQ_COMMON_NODE_TYPE_SIZE_MASK) << XGMI_TX_EQ_COMMON_NODE_TYPE_SHIFT) | \
                                                                   ((EqPost & XGMI_TX_EQ_DATA_EQ_POST_SIZE_MASK) << XGMI_TX_EQ_DATA_EQ_POST_SHIFT) | \
                                                                   ((EqMain & XGMI_TX_EQ_DATA_EQ_MAIN_SIZE_MASK) << XGMI_TX_EQ_DATA_EQ_MAIN_SHIFT) | \
                                                                   ((EqPre & XGMI_TX_EQ_DATA_EQ_PRE_SIZE_MASK) << XGMI_TX_EQ_DATA_EQ_PRE_SHIFT)))

#define XGMI_TX_EQ_DATA_COMPACT_EQ_PRE_SHIFT            0
#define XGMI_TX_EQ_DATA_COMPACT_EQ_PRE_SIZE_MASK        XGMI_TX_EQ_DATA_EQ_PRE_SIZE_MASK
#define XGMI_TX_EQ_DATA_COMPACT_EQ_PRE_MASK             (XGMI_TX_EQ_DATA_COMPACT_EQ_PRE_SIZE_MASK << XGMI_TX_EQ_DATA_COMPACT_EQ_PRE_SHIFT)
#define XGMI_TX_EQ_DATA_COMPACT_EQ_MAIN_SHIFT           6
#define XGMI_TX_EQ_DATA_COMPACT_EQ_MAIN_SIZE_MASK       XGMI_TX_EQ_DATA_EQ_MAIN_SIZE_MASK
#define XGMI_TX_EQ_DATA_COMPACT_EQ_MAIN_MASK            (XGMI_TX_EQ_DATA_COMPACT_EQ_MAIN_SIZE_MASK << XGMI_TX_EQ_DATA_COMPACT_EQ_MAIN_SHIFT)
#define XGMI_TX_EQ_DATA_COMPACT_EQ_POST_SHIFT           12
#define XGMI_TX_EQ_DATA_COMPACT_EQ_POST_SIZE_MASK       XGMI_TX_EQ_DATA_EQ_POST_SIZE_MASK
#define XGMI_TX_EQ_DATA_COMPACT_EQ_POST_MASK            (XGMI_TX_EQ_DATA_COMPACT_EQ_POST_SIZE_MASK << XGMI_TX_EQ_DATA_COMPACT_EQ_POST_SHIFT)

typedef struct _XGMI_TX_EQ_DATA_LIST_COMPACT {
  UINT32  EqPre0:6;                           ///< EQ_PRE/TxCoeffPre for 0
  UINT32  EqMain0:6;                          ///< EQ_MAIN/TxCoeffCurs for 0
  UINT32  EqPost0:6;                          ///< EQ_POST/TxCoeffPost for 0
  UINT32  EqPre1:6;                           ///< EQ_PRE/TxCoeffPre for 1
  UINT32  EqMain1:6;                          ///< EQ_MAIN/TxCoeffCurs for 1
  UINT32  EqPost1_1_0:2;                      ///< EQ_POST/TxCoeffPost for 1

  UINT32  EqPost1_5_2:4;                       ///< EQ_POST/TxCoeffPost for 1
  UINT32  EqPre2:6;                           ///< EQ_PRE/TxCoeffPre for 2
  UINT32  EqMain2:6;                          ///< EQ_MAIN/TxCoeffCurs for 2
  UINT32  EqPost2:6;                          ///< EQ_POST/TxCoeffPost for 2
  UINT32  EqPre3:6;                           ///< EQ_PRE/TxCoeffPre for 3
  UINT32  EqMain3_3_0:4;                      ///< EQ_MAIN/TxCoeffCurs for 3

  UINT32  EqMain3_5_4:2;                      ///< EQ_MAIN/TxCoeffCurs for 3
  UINT32  EqPost3:6;                          ///< EQ_POST/TxCoeffPost for 3
  UINT32  EqPre4:6;                           ///< EQ_PRE/TxCoeffPre for 4
  UINT32  EqMain4:6;                          ///< EQ_MAIN/TxCoeffCurs for 4
  UINT32  EqPost4:6;                          ///< EQ_POST/TxCoeffPost for 4
  UINT32  EqPre5:6;                           ///< EQ_PRE/TxCoeffPre for 5

  UINT32  EqMain5:6;                          ///< EQ_MAIN/TxCoeffCurs for 5
  UINT32  EqPost5:6;                          ///< EQ_POST/TxCoeffPost for 5
  UINT32  EqPre6:6;                           ///< EQ_PRE/TxCoeffPre for 6
  UINT32  EqMain6:6;                          ///< EQ_MAIN/TxCoeffCurs for 6
  UINT32  EqPost6:6;                          ///< EQ_POST/TxCoeffPost for 6
  UINT32  EqPre7_1_0:2;                       ///< EQ_PRE/TxCoeffPre for 7

  UINT32  EqPre7_5_2:4;                       ///< EQ_PRE/TxCoeffPre for 7
  UINT32  EqMain7:6;                          ///< EQ_MAIN/TxCoeffCurs for 7
  UINT32  EqPost7:6;                          ///< EQ_POST/TxCoeffPost for 7
  UINT32  EqPre8:6;                           ///< EQ_PRE/TxCoeffPre for 8
  UINT32  EqMain8:6;                          ///< EQ_MAIN/TxCoeffCurs for 8
  UINT32  EqPost8_3_0:4;                      ///< EQ_POST/TxCoeffPost for 8

  UINT32  EqPost8_5_4:2;                      ///< EQ_POST/TxCoeffPost for 8
  UINT32  EqPre9:6;                           ///< EQ_PRE/TxCoeffPre for 9
  UINT32  EqMain9:6;                          ///< EQ_MAIN/TxCoeffCurs for 9
  UINT32  EqPost9:6;                          ///< EQ_POST/TxCoeffPost for 9
  UINT32  EqPre10:6;                          ///< EQ_PRE/TxCoeffPre for 10
  UINT32  EqMain10:6;                         ///< EQ_MAIN/TxCoeffCurs for 10

  UINT32  EqPost10:6;                         ///< EQ_POST/TxCoeffPost for 10
  UINT32  EqPre11:6;                          ///< EQ_PRE/TxCoeffPre for 11
  UINT32  EqMain11:6;                         ///< EQ_MAIN/TxCoeffCurs for 11
  UINT32  EqPost11:6;                         ///< EQ_POST/TxCoeffPost for 11
  UINT32  EqPre12:6;                          ///< EQ_PRE/TxCoeffPre for 12
  UINT32  EqMain12_1_0:2;                     ///< EQ_MAIN/TxCoeffCurs for 12

  UINT32  EqMain12_5_2:4;                     ///< EQ_MAIN/TxCoeffCurs for 12
  UINT32  EqPost12:6;                         ///< EQ_POST/TxCoeffPost for 12
  UINT32  EqPre13:6;                          ///< EQ_PRE/TxCoeffPre for 13
  UINT32  EqMain13:6;                         ///< EQ_MAIN/TxCoeffCurs for 13
  UINT32  EqPost13:6;                         ///< EQ_POST/TxCoeffPost for 13
  UINT32  EqPre14_3_0:4;                      ///< EQ_PRE/TxCoeffPre for 14

  UINT32  EqPre14_5_4:2;                      ///< EQ_PRE/TxCoeffPre for 14
  UINT32  EqMain14:6;                         ///< EQ_MAIN/TxCoeffCurs for 14
  UINT32  EqPost14:6;                         ///< EQ_POST/TxCoeffPost for 14
  UINT32  EqPre15:6;                          ///< EQ_PRE/TxCoeffPre for 15
  UINT32  EqMain15:6;                         ///< EQ_MAIN/TxCoeffCurs for 15
  UINT32  EqPost15:6;                         ///< EQ_POST/TxCoeffPost for 15

} XGMI_TX_EQ_DATA_LIST_COMPACT;

#define MAKE_TX_EQ_LIST_COMPACT_DATA_SUB(EqMain, EqPost, EqPre)     ((UINT32) ( \
                                                                                ((EqPost & XGMI_TX_EQ_DATA_COMPACT_EQ_POST_SIZE_MASK) << XGMI_TX_EQ_DATA_COMPACT_EQ_POST_SHIFT) | \
                                                                                ((EqMain & XGMI_TX_EQ_DATA_COMPACT_EQ_MAIN_SIZE_MASK) << XGMI_TX_EQ_DATA_COMPACT_EQ_MAIN_SHIFT) | \
                                                                                ((EqPre & XGMI_TX_EQ_DATA_COMPACT_EQ_PRE_SIZE_MASK) << XGMI_TX_EQ_DATA_COMPACT_EQ_PRE_SHIFT)))
#define MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW0_1ST(EqDw0)         ((UINT32)  EqDw0 & 0x3FFFF)         // Lane0 18 bits
#define MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW0_2ND(EqDw1)         (((UINT32) EqDw1 & 0x03FFF) << 18)  // Lane1 14 bits

#define MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW1_1ST(EqDw1)         (((UINT32) EqDw1 & 0x3C000) >> 14)  // Lane1  4 bits
#define MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW1_2ND(EqDw2)         (((UINT32) EqDw2 & 0x3FFFF) << 4)   // Lane2 18 bits
#define MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW1_3RD(EqDw3)         (((UINT32) EqDw3 & 0x003FF) << 22)  // Lane3 10 bits

#define MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW2_1ST(EqDw3)         (((UINT32) EqDw3 & 0x3FC00) >> 10)  // Lane3  8 bits
#define MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW2_2ND(EqDw4)         (((UINT32) EqDw4 & 0x3FFFF) << 8)   // Lane4 18 bits
#define MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW2_3RD(EqDw5)         (((UINT32) EqDw5 & 0x0003F) << 26)  // Lane5  6 bits

#define MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW3_1ST(EqDw5)         (((UINT32) EqDw5 & 0x3FFC0) >> 6)   // Lane5 12 bits
#define MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW3_2ND(EqDw6)         (((UINT32) EqDw6 & 0x3FFFF) << 12)  // Lane6 18 bits
#define MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW3_3RD(EqDw7)         (((UINT32) EqDw7 & 0x00003) << 30)  // Lane7  2 bits

#define MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW4_1ST(EqDw7)         (((UINT32) EqDw7 & 0x3FFFC) >> 2)   // Lane7 16 bits
#define MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW4_2ND(EqDw8)         (((UINT32) EqDw8 & 0x0FFFF) << 16)  // Lane8 16 bits

#define MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW5_1ST(EqDw8)         (((UINT32) EqDw8 & 0x30000) >> 16)  // Lane8  2 bits
#define MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW5_2ND(EqDw9)         (((UINT32) EqDw9 & 0x3FFFF) << 2)   // Lane9 18 bits
#define MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW5_3RD(EqDw10)        (((UINT32) EqDw10 & 0x00FFF) << 20) // Lane10 12 bits

#define MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW6_1ST(EqDw10)        (((UINT32) EqDw10 & 0x3F000) >> 12) // Lane10  6 bits
#define MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW6_2ND(EqDw11)        (((UINT32) EqDw11 & 0x3FFFF) << 6)  // Lane11 18 bits
#define MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW6_3RD(EqDw12)        (((UINT32) EqDw12 & 0x000FF) << 24) // Lane12  8 bits

#define MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW7_1ST(EqDw12)        (((UINT32) EqDw12 & 0x3FF00) >> 8)  // Lane12 10 bits
#define MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW7_2ND(EqDw13)        (((UINT32) EqDw13 & 0x3FFFF) << 10) // Lane13 18 bits
#define MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW7_3RD(EqDw14)        (((UINT32) EqDw14 & 0x0000F) << 28) // Lane14  4 bits

#define MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW8_1ST(EqDw14)        (((UINT32) EqDw14 & 0x3FFF0) >> 4)  // Lane14 14 bits
#define MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW8_2ND(EqDw15)        (((UINT32) EqDw15 & 0x3FFFF) << 14) // Lane15 18 bits

#define MAKE_TX_EQ_LIST_COMPACT_DATA_DW0(EqDw0, EqDw1)              (MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW0_1ST(EqDw0) | MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW0_2ND(EqDw1))
#define MAKE_TX_EQ_LIST_COMPACT_DATA_DW1(EqDw1, EqDw2, EqDw3)       (MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW1_1ST(EqDw1) | MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW1_2ND(EqDw2) | MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW1_3RD(EqDw3))
#define MAKE_TX_EQ_LIST_COMPACT_DATA_DW2(EqDw3, EqDw4, EqDw5)       (MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW2_1ST(EqDw3) | MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW2_2ND(EqDw4) | MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW2_3RD(EqDw5))
#define MAKE_TX_EQ_LIST_COMPACT_DATA_DW3(EqDw5, EqDw6, EqDw7)       (MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW3_1ST(EqDw5) | MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW3_2ND(EqDw6) | MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW3_3RD(EqDw7))
#define MAKE_TX_EQ_LIST_COMPACT_DATA_DW4(EqDw7, EqDw8)              (MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW4_1ST(EqDw7) | MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW4_2ND(EqDw8))
#define MAKE_TX_EQ_LIST_COMPACT_DATA_DW5(EqDw8, EqDw9, EqDw10)      (MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW5_1ST(EqDw8) | MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW5_2ND(EqDw9) | MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW5_3RD(EqDw10))
#define MAKE_TX_EQ_LIST_COMPACT_DATA_DW6(EqDw10, EqDw11, EqDw12)    (MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW6_1ST(EqDw10) | MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW6_2ND(EqDw11) | MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW6_3RD(EqDw12))
#define MAKE_TX_EQ_LIST_COMPACT_DATA_DW7(EqDw12, EqDw13, EqDw14)    (MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW7_1ST(EqDw12) | MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW7_2ND(EqDw13) | MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW7_3RD(EqDw14))
#define MAKE_TX_EQ_LIST_COMPACT_DATA_DW8(EqDw14, EqDw15)            (MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW8_1ST(EqDw14) | MAKE_TX_EQ_LIST_COMPACT_DATA_SUB_POS_DW8_2ND(EqDw15))

#define MAKE_TX_EQ_LIST_COMPACT_DATA(EqDw0, EqDw1, EqDw2, EqDw3, EqDw4, EqDw5, EqDw6, EqDw7, EqDw8, EqDw9, EqDw10, EqDw11, EqDw12, EqDw13, EqDw14, EqDw15) \
                                                                    MAKE_TX_EQ_LIST_COMPACT_DATA_DW0(EqDw0, EqDw1),           \
                                                                    MAKE_TX_EQ_LIST_COMPACT_DATA_DW1(EqDw1, EqDw2, EqDw3),    \
                                                                    MAKE_TX_EQ_LIST_COMPACT_DATA_DW2(EqDw3, EqDw4, EqDw5),    \
                                                                    MAKE_TX_EQ_LIST_COMPACT_DATA_DW3(EqDw5, EqDw6, EqDw7),    \
                                                                    MAKE_TX_EQ_LIST_COMPACT_DATA_DW4(EqDw7, EqDw8),           \
                                                                    MAKE_TX_EQ_LIST_COMPACT_DATA_DW5(EqDw8, EqDw9, EqDw10),   \
                                                                    MAKE_TX_EQ_LIST_COMPACT_DATA_DW6(EqDw10, EqDw11, EqDw12), \
                                                                    MAKE_TX_EQ_LIST_COMPACT_DATA_DW7(EqDw12, EqDw13, EqDw14), \
                                                                    MAKE_TX_EQ_LIST_COMPACT_DATA_DW8(EqDw14, EqDw15)


// Termination node of XGMI TX EQ setting of frequency table
#define MAKE_TX_EQ_FREQ_END()                           ((UINT32) (((XGMI_TX_EQ_NODE_TYPE_FREQ_END & XGMI_TX_EQ_COMMON_NODE_TYPE_SIZE_MASK) << XGMI_TX_EQ_COMMON_NODE_TYPE_SHIFT)))

// Termination node of XGMI TX EQ setting table
#define MAKE_TX_EQ_END()                                ((UINT32) (((XGMI_TX_EQ_NODE_TYPE_END & XGMI_TX_EQ_COMMON_NODE_TYPE_SIZE_MASK) << XGMI_TX_EQ_COMMON_NODE_TYPE_SHIFT)))


// XGMI TX EQ union
typedef union _XGMI_TX_EQ_UNION {
  UINT32                  Raw;                  ///< Raw data
  XGMI_TX_EQ_COMMON       Common;               ///< Common structure
  XGMI_TX_EQ_FREQ         Freq;                 ///< Frequency structure
  XGMI_TX_EQ_ATTR         Attr;                 ///< Attribute structure
  XGMI_TX_EQ_DATA         Data;                 ///< Data structure
} XGMI_TX_EQ_UNION;

// Macro for all system lanes
#define MAKE_TX_EQ_ALL_SYS_LANES()                      MAKE_TX_EQ_ATTR(XGMI_ALL_SOCKETS, XGMI_ALL_DIES, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_PAIR)
#define MAKE_TX_EQ_EACH_SYS_LANES()                     MAKE_TX_EQ_ATTR(XGMI_ALL_SOCKETS, XGMI_ALL_DIES, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST)
// Macros for socket 0
#define MAKE_TX_EQ_SOCKET0_DIE_LANE(DieMask, LaneMask, DataMode)    MAKE_TX_EQ_ATTR(XGMI_SOCKET0, DieMask, LaneMask, DataMode)
#define MAKE_TX_EQ_SOCKET0_DIE_LANE_PAIR(DieMask, LaneMask)         MAKE_TX_EQ_ATTR(XGMI_SOCKET0, DieMask, LaneMask, XGMI_TX_EQ_DATA_MODE_PAIR)
#define MAKE_TX_EQ_SOCKET0_DIE_LANE_LIST(DieMask, LaneMask)         MAKE_TX_EQ_ATTR(XGMI_SOCKET0, DieMask, LaneMask, XGMI_TX_EQ_DATA_MODE_LIST)
#define MAKE_TX_EQ_SOCKET0_DIE0_ALL_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET0, XGMI_DIE0, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_PAIR)
#define MAKE_TX_EQ_SOCKET0_DIE1_ALL_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET0, XGMI_DIE1, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_PAIR)
#define MAKE_TX_EQ_SOCKET0_DIE2_ALL_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET0, XGMI_DIE2, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_PAIR)
#define MAKE_TX_EQ_SOCKET0_DIE3_ALL_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET0, XGMI_DIE3, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_PAIR)
#define MAKE_TX_EQ_SOCKET0_DIE4_ALL_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET0, XGMI_DIE4, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_PAIR)
#define MAKE_TX_EQ_SOCKET0_DIE5_ALL_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET0, XGMI_DIE5, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_PAIR)
#define MAKE_TX_EQ_SOCKET0_DIE6_ALL_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET0, XGMI_DIE6, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_PAIR)
#define MAKE_TX_EQ_SOCKET0_DIE7_ALL_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET0, XGMI_DIE7, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_PAIR)
#define MAKE_TX_EQ_SOCKET0_DIE0_EACH_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET0, XGMI_DIE0, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST)
#define MAKE_TX_EQ_SOCKET0_DIE1_EACH_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET0, XGMI_DIE1, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST)
#define MAKE_TX_EQ_SOCKET0_DIE2_EACH_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET0, XGMI_DIE2, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST)
#define MAKE_TX_EQ_SOCKET0_DIE3_EACH_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET0, XGMI_DIE3, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST)
#define MAKE_TX_EQ_SOCKET0_DIE4_EACH_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET0, XGMI_DIE4, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST)
#define MAKE_TX_EQ_SOCKET0_DIE5_EACH_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET0, XGMI_DIE5, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST)
#define MAKE_TX_EQ_SOCKET0_DIE6_EACH_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET0, XGMI_DIE6, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST)
#define MAKE_TX_EQ_SOCKET0_DIE7_EACH_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET0, XGMI_DIE7, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST)
#define MAKE_TX_EQ_SOCKET0_DIE0_EACH_LANES_COMPACT()             MAKE_TX_EQ_ATTR(XGMI_SOCKET0, XGMI_DIE0, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST_COMPACT)
#define MAKE_TX_EQ_SOCKET0_DIE1_EACH_LANES_COMPACT()             MAKE_TX_EQ_ATTR(XGMI_SOCKET0, XGMI_DIE1, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST_COMPACT)
#define MAKE_TX_EQ_SOCKET0_DIE2_EACH_LANES_COMPACT()             MAKE_TX_EQ_ATTR(XGMI_SOCKET0, XGMI_DIE2, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST_COMPACT)
#define MAKE_TX_EQ_SOCKET0_DIE3_EACH_LANES_COMPACT()             MAKE_TX_EQ_ATTR(XGMI_SOCKET0, XGMI_DIE3, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST_COMPACT)
#define MAKE_TX_EQ_SOCKET0_DIE4_EACH_LANES_COMPACT()             MAKE_TX_EQ_ATTR(XGMI_SOCKET0, XGMI_DIE4, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST_COMPACT)
#define MAKE_TX_EQ_SOCKET0_DIE5_EACH_LANES_COMPACT()             MAKE_TX_EQ_ATTR(XGMI_SOCKET0, XGMI_DIE5, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST_COMPACT)
#define MAKE_TX_EQ_SOCKET0_DIE6_EACH_LANES_COMPACT()             MAKE_TX_EQ_ATTR(XGMI_SOCKET0, XGMI_DIE6, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST_COMPACT)
#define MAKE_TX_EQ_SOCKET0_DIE7_EACH_LANES_COMPACT()             MAKE_TX_EQ_ATTR(XGMI_SOCKET0, XGMI_DIE7, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST_COMPACT)

// Macros for socket 1
#define MAKE_TX_EQ_SOCKET1_DIE_LANE(DieMask, LaneMask, DataMode)    MAKE_TX_EQ_ATTR(XGMI_SOCKET1, DieMask, LaneMask, DataMode)
#define MAKE_TX_EQ_SOCKET1_DIE_LANE_PAIR(DieMask, LaneMask)         MAKE_TX_EQ_ATTR(XGMI_SOCKET1, DieMask, LaneMask, XGMI_TX_EQ_DATA_MODE_PAIR)
#define MAKE_TX_EQ_SOCKET1_DIE_LANE_LIST(DieMask, LaneMask)         MAKE_TX_EQ_ATTR(XGMI_SOCKET1, DieMask, LaneMask, XGMI_TX_EQ_DATA_MODE_LIST)
#define MAKE_TX_EQ_SOCKET1_DIE0_ALL_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET1, XGMI_DIE0, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_PAIR)
#define MAKE_TX_EQ_SOCKET1_DIE1_ALL_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET1, XGMI_DIE1, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_PAIR)
#define MAKE_TX_EQ_SOCKET1_DIE2_ALL_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET1, XGMI_DIE2, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_PAIR)
#define MAKE_TX_EQ_SOCKET1_DIE3_ALL_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET1, XGMI_DIE3, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_PAIR)
#define MAKE_TX_EQ_SOCKET1_DIE4_ALL_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET1, XGMI_DIE4, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_PAIR)
#define MAKE_TX_EQ_SOCKET1_DIE5_ALL_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET1, XGMI_DIE5, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_PAIR)
#define MAKE_TX_EQ_SOCKET1_DIE6_ALL_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET1, XGMI_DIE6, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_PAIR)
#define MAKE_TX_EQ_SOCKET1_DIE7_ALL_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET1, XGMI_DIE7, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_PAIR)
#define MAKE_TX_EQ_SOCKET1_DIE0_EACH_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET1, XGMI_DIE0, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST)
#define MAKE_TX_EQ_SOCKET1_DIE1_EACH_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET1, XGMI_DIE1, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST)
#define MAKE_TX_EQ_SOCKET1_DIE2_EACH_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET1, XGMI_DIE2, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST)
#define MAKE_TX_EQ_SOCKET1_DIE3_EACH_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET1, XGMI_DIE3, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST)
#define MAKE_TX_EQ_SOCKET1_DIE4_EACH_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET1, XGMI_DIE4, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST)
#define MAKE_TX_EQ_SOCKET1_DIE5_EACH_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET1, XGMI_DIE5, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST)
#define MAKE_TX_EQ_SOCKET1_DIE6_EACH_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET1, XGMI_DIE6, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST)
#define MAKE_TX_EQ_SOCKET1_DIE7_EACH_LANES()             MAKE_TX_EQ_ATTR(XGMI_SOCKET1, XGMI_DIE7, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST)
#define MAKE_TX_EQ_SOCKET1_DIE0_EACH_LANES_COMPACT()             MAKE_TX_EQ_ATTR(XGMI_SOCKET1, XGMI_DIE0, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST_COMPACT)
#define MAKE_TX_EQ_SOCKET1_DIE1_EACH_LANES_COMPACT()             MAKE_TX_EQ_ATTR(XGMI_SOCKET1, XGMI_DIE1, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST_COMPACT)
#define MAKE_TX_EQ_SOCKET1_DIE2_EACH_LANES_COMPACT()             MAKE_TX_EQ_ATTR(XGMI_SOCKET1, XGMI_DIE2, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST_COMPACT)
#define MAKE_TX_EQ_SOCKET1_DIE3_EACH_LANES_COMPACT()             MAKE_TX_EQ_ATTR(XGMI_SOCKET1, XGMI_DIE3, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST_COMPACT)
#define MAKE_TX_EQ_SOCKET1_DIE4_EACH_LANES_COMPACT()             MAKE_TX_EQ_ATTR(XGMI_SOCKET1, XGMI_DIE4, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST_COMPACT)
#define MAKE_TX_EQ_SOCKET1_DIE5_EACH_LANES_COMPACT()             MAKE_TX_EQ_ATTR(XGMI_SOCKET1, XGMI_DIE5, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST_COMPACT)
#define MAKE_TX_EQ_SOCKET1_DIE6_EACH_LANES_COMPACT()             MAKE_TX_EQ_ATTR(XGMI_SOCKET1, XGMI_DIE6, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST_COMPACT)
#define MAKE_TX_EQ_SOCKET1_DIE7_EACH_LANES_COMPACT()             MAKE_TX_EQ_ATTR(XGMI_SOCKET1, XGMI_DIE7, XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST_COMPACT)

#define MAKE_TX_EQ_PAIR(Attr, Data)                           Attr, Data
#define MAKE_TX_EQ_LIST(Attr, Data0, ...)                     Attr, Data0, __VA_ARGS__
#define MAKE_TX_EQ_LIST_COMPACT(Attr, Lane0, Lane1, Lane2, Lane3, Lane4, Lane5, Lane6, Lane7, Lane8, Lane9, Lane10, Lane11, Lane12, Lane13, Lane14, Lane15)  \
                                                              Attr, MAKE_TX_EQ_LIST_COMPACT_DATA(Lane0, Lane1, Lane2, Lane3, Lane4, Lane5, Lane6, Lane7, Lane8, Lane9, Lane10, Lane11, Lane12, Lane13, Lane14, Lane15)
#define MAKE_TX_EQ_FREQ_TABLE(SpeedMask, TxEqPairOrList, ...)  MAKE_TX_EQ_FREQ_TBL(SpeedMask), 0, 0, TxEqPairOrList, __VA_ARGS__, MAKE_TX_EQ_FREQ_END()

typedef struct _XGMI_TX_EQ_COMPACT_LANE_PER_DIE {
  union {
  UINT32                  AttrLoc;              ///< Must be XGMI_ALL_LANES, XGMI_TX_EQ_DATA_MODE_LIST_COMPACT
  XGMI_TX_EQ_ATTR         Attr;                 ///< Attribute structure
  } unionAttr;
  XGMI_TX_EQ_DATA_LIST_COMPACT    CompactListData;
} XGMI_TX_EQ_COMPACT_LANE_PER_DIE;

typedef struct _XGMI_TX_EQ_HEAD {
    UINT32                SpeedMask;
    UINT32                SocGeneration;
    UINT32                SocPackage;
} XGMI_TX_EQ_HEAD;

typedef struct _XGMI_TX_EQ_SL1 {
    XGMI_TX_EQ_COMPACT_LANE_PER_DIE     D0;
    XGMI_TX_EQ_COMPACT_LANE_PER_DIE     D1;
    XGMI_TX_EQ_COMPACT_LANE_PER_DIE     D2;
    XGMI_TX_EQ_COMPACT_LANE_PER_DIE     D3;
    XGMI_TX_EQ_COMPACT_LANE_PER_DIE     D4;
    XGMI_TX_EQ_COMPACT_LANE_PER_DIE     D5;
    XGMI_TX_EQ_COMPACT_LANE_PER_DIE     D6;
    XGMI_TX_EQ_COMPACT_LANE_PER_DIE     D7;
} XGMI_TX_EQ_SL1;

typedef struct _XGMI_TX_EQ_SL1R2 {
    XGMI_TX_EQ_COMPACT_LANE_PER_DIE     D0;
    XGMI_TX_EQ_COMPACT_LANE_PER_DIE     D1;
    XGMI_TX_EQ_COMPACT_LANE_PER_DIE     D2;
    XGMI_TX_EQ_COMPACT_LANE_PER_DIE     D3;
} XGMI_TX_EQ_SL1R2;

typedef struct _XGMI_TX_EQ_DM1 {
    XGMI_TX_EQ_COMPACT_LANE_PER_DIE     D0;
    XGMI_TX_EQ_COMPACT_LANE_PER_DIE     D1;
} XGMI_TX_EQ_DM1;

#define SOC_GEN_1 0
#define SOC_GEN_2 1
#define SOC_GEN_3 2
#define SOC_SL1   4
#define SOC_DM1   6
#define SOC_SL1R2 7

//4die SOC - package SL1
#define SL1_MAKE_TX_EQ_FREQ_TABLE_COMPACT(SpeedMask, SocGeneration, SocPackage, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7) \
    MAKE_TX_EQ_FREQ_TBL(SpeedMask), (UINT32)(SocGeneration), (UINT32)(SocPackage), SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, MAKE_TX_EQ_FREQ_END()

//2die SOC - package SL1r2
#define SL1R2_MAKE_TX_EQ_FREQ_TABLE_COMPACT(SpeedMask, SocGeneration, SocPackage, SD0, SD1, SD2, SD3) \
    MAKE_TX_EQ_FREQ_TBL(SpeedMask), SocGeneration, SocPackage, SD0, SD1, SD2, SD3, MAKE_TX_EQ_FREQ_END()

//1die SOC - package DM1
#define DM1_MAKE_TX_EQ_FREQ_TABLE_COMPACT(SpeedMask, SocGeneration, SocPackage, SD0, SD1) \
    MAKE_TX_EQ_FREQ_TBL(SpeedMask), SocGeneration, SocPackage, SD0, SD1, MAKE_TX_EQ_FREQ_END()

///< Total 8 socket die indice, no direct mapping
#define MAKE_TX_EQ_FREQ_TABLE_COMPACT(SpeedMask, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7)  \
      MAKE_TX_EQ_FREQ_TBL(SpeedMask), SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, MAKE_TX_EQ_FREQ_END()

#define MAKE_TX_EQ_LANE_DATA(EqMain, EqPost, EqPre)         MAKE_TX_EQ_LIST_COMPACT_DATA_SUB(EqMain, EqPost, EqPre)

/*----------------------------------------------------------------------------
 *                           FUNCTIONS PROTOTYPE
 *
 *----------------------------------------------------------------------------
 */

#define  DF_MEM_INTLV_SOCKET  3
#define  DF_MEM_INTLV_DIE     2
#define  DF_MEM_INTLV_CHANNEL 1
#define  DF_MEM_INTLV_NONE    0

#define  DF_DRAM_INTLV_SIZE_256   0
#define  DF_DRAM_INTLV_SIZE_512   1
#define  DF_DRAM_INTLV_SIZE_1024  2
#define  DF_DRAM_INTLV_SIZE_2048  3

#define  PSP_ENABLE_DEBUG_MODE_PRODUCTION  0
#define  PSP_ENABLE_DEBUG_MODE_DEBUG       1
#define  PSP_ENABLE_DEBUG_MODE_DEFAULT     PSP_ENABLE_DEBUG_MODE_PRODUCTION
#define  PSP_ENABLE_DEBUG_MODE_MAX_CHOICE  PSP_ENABLE_DEBUG_MODE_DEBUG


BOOLEAN
ApcbAblIdsParam_SkipCheck (
  IN     UINT16             ApcbParamToken,
  IN     UINT8              ApcbTimePoint,
  IN     AMD_CONFIG_PARAMS  *StdHeader
  );

BOOLEAN
ApcbAblIdsGetCbsDbgParameter (
  IN     UINT16             ApcbParamToken,
  IN     UINT8              ApcbTimePoint,
  IN OUT UINT8              *Buffer,
  IN OUT UINT8              *Size,
  IN     AMD_CONFIG_PARAMS  *StdHeader
  );

#if (APCB_IDS_PARAMETER_ENABLED == TRUE)

  /*
   * APCB IDS Options Skip Macro
   *  If the timepoint and token match, the code will be skipped
   */
  #define APCB_IDS_PARAM_SKIP(ApcbParamToken, ApcbTimePoint, StdHeader)\
    if (ApcbAblIdsParam_SkipCheck(ApcbTimePoint, ApcbParamToken, (StdHeader)))

  /*
   * IDS Options Insert Macro
   */
  #define APCB_IDS_PARAM_INSERT(function, param, timepoint)\
    IDS_HDT_CONSOLE (MEM_FLOW, "\nAPCB IDS OPTIONS INSERT START: " #function "\n");\
    function (param, timepoint);\
    IDS_HDT_CONSOLE (MEM_FLOW, "\nAPCB IDS OPTIONS INSERT END: " #function "\n");\

  /*
   * IDS Options Get Token Macro
   */
  #define APCB_IDS_GET_CBS_DBG_PARAMETER(ApcbParamToken, ApcbTimePoint, Buffer, Size, StdHeader)\
    ApcbAblIdsGetCbsDbgParameter(ApcbParamToken, ApcbTimePoint, (Buffer), (Size), (StdHeader));\

  /*
   * IDS Options Internal Token Override Macro
   */
  #define APCB_IDS_OVERRIDE_CBS_DBG_PARAMETER(ApcbParamToken, ApcbTimePoint, Buffer, Size, StdHeader)\
    ApcbAblIdsOverrideCbsDbgParameter(ApcbParamToken, ApcbTimePoint, (Buffer), (Size), (StdHeader));\

#else // (APCB_IDS_PARAMETER_ENABLED == TRUE)

  #define APCB_IDS_PARAM_SKIP(ApcbTimePoint, ApcbParamToken, StdHeader)
  #define APCB_IDS_PARAM_INSERT(function, param, timepoint)
  #define APCB_IDS_GET_CBS_DBG_PARAMETER(ApcbParamToken, ApcbTimePoint, Buffer, Size, StdHeader)
  #define APCB_IDS_OVERRIDE_CBS_DBG_PARAMETER(ApcbParamToken, ApcbTimePoint, Buffer, Size, StdHeader)

#endif // (APCB_IDS_PARAMETER_ENABLED == TRUE)



 //Note a is from 0 to 31
#define BP_SHIFT(a)   ((UINT64)1 << a)

// Breakpoint Definition
//UMC BPs
#define APCB_BP_UMC_PHASE_1_END                 BP_SHIFT (0)     // End of Phase 1 Initialization  - all addressing/UMC configs done
#define APCB_BP_UMC_START_PMU_ON_IMAGE          BP_SHIFT (1)       // Start PMU on imagex  - PHY init/SRAM Msg Block done ; just staring 1D training
#define APCB_BP_UMC_MISSION_MODE_CONFIG         BP_SHIFT (2)     // UMC mision mode configuration
#define APCB_BP_UMC_PMU_FINISHED                BP_SHIFT (3)     // PMU Finish
#define APCB_BP_UMC_2D_TRAINING_DONE            BP_SHIFT (4)     // PMU Based Training complete  - 2D Training done
#define APCB_BP_UMC_MEM_PHASE_2_END             BP_SHIFT (5)     // End of Phase 2 Initialization  - Mission mode timings updated (turn around timings)
#define APCB_BP_UMC_BEFORE_INITIAL_PSTATE        BP_SHIFT (6)     // Before initial P-state change
#define APCB_BP_UMC_AFTER_INITIAL_PSTATE         BP_SHIFT (7)     // After initial P-state change
#define APCB_BP_UMC_BEFORE_DRAM_READY           BP_SHIFT (8)     // Before set UMC DramReady = 1
#define APCB_BP_UMC_BEFORE_INITIAL_IN_PSTATE_FUNCTION  BP_SHIFT (9)     // Before initial P-state change in Pstate function
#define APCB_BP_UMC_AFTER_RECOVERY_MOP_FUNCTION  BP_SHIFT (10)     // After Recovery MOP array function
#define APCB_BP_UMC_AFTER_RECOVERY_MOP_SR_DSTATE1_FUNCTION  BP_SHIFT (15)     // After Recover MOP array init but beore Self Refresh DSTATE1 change

//DF BPs
#define APCB_BP_DF_INIT_START                   BP_SHIFT (10)
#define APCB_BP_DF_BEFORE_LINK_TRAINING         BP_SHIFT (11)
#define APCB_BP_DF_LINK_TRAINING_COMPLETE       BP_SHIFT (12)
#define APCB_BP_DF_BEFORE_CREDIT_RELEASE        BP_SHIFT (13)
#define APCB_BP_DF_INIT_COMPLETE                BP_SHIFT (14)

//Other BPS
#define APCB_BP_CUSTOM                          BP_SHIFT (30)
#define APCB_BREAKPOINT_DONE                    BP_SHIFT (31)


//BP related Register definitions
#define UMC_CTRL_SMN_BASE 0x51000
#define ENV_CONTROL_UMC_SCRATCH_REG_0   (UMC_CTRL_SMN_BASE | 0x050)    // UserDataPattern0
#define ENV_CONTROL_UMC_SCRATCH_REG_1   (UMC_CTRL_SMN_BASE | 0x054)    // UserDataPattern1
#define ENV_CONTROL_UMC_SCRATCH_REG_2   (UMC_CTRL_SMN_BASE | 0x058)    // UserDataPattern2
#define ENV_CONTROL_UMC_SCRATCH_REG_3   (UMC_CTRL_SMN_BASE | 0x05C)    // UserDataPattern3

#define ABL_DBG_SMN_DATA_MBOX_0 ENV_CONTROL_UMC_SCRATCH_REG_2   // Data Mailbox
#define ABL_DBG_SMN_CMD_MBOX_1 ENV_CONTROL_UMC_SCRATCH_REG_3   // Command Mailbox

#define ABL_DBG_CMD_ABL_BP_FOUND  0x5000C001         // Command from ABL to script indicating that BP found
#define ABL_DBG_CMD_ABL_BOOT_DONE 0x5000DEAD         // Command from ABL to script indicating that All BPs are done
#define ABL_DBG_CMD_SCRIPT_CONTINUE   0xC001C001        // Command from script to ABL indicating continue execution
#define ABL_DBG_CMD_ABL_BP_INIT  0xC001BEE5       // Command from ABL to script indicating init breakpoints
#define ABL_DBG_CMD_SCRIPT_BP_LIST  0xC001BB11          // Command from script to indicating breakpoints list
#define ABL_DBG_CMD_ABL_HDTOUT_INIT  0x99CCEEEE    // Command from ABL to script indicating init ABL HDTOUT
#define ABL_DBG_CMD_ABL_HDTOUT_EXIT  0x99CCD00E    // Command from ABL to script indicating that All HDTOUT print are finished
#define ABL_DBG_CMD_ABL_HDTOUT_PRINT 0x99CC9000    // Command from ABL to script indicating that print ASCII from Script register buffer, last 3 nibble indicated the print size

#define APCB_BREAKPOINT_SMN_DATA_MBOX_0 ENV_CONTROL_UMC_SCRATCH_REG_2   // Data Mailbox
#define APCB_BREAKPOINT_SMN_CMD_MBOX_1 ENV_CONTROL_UMC_SCRATCH_REG_3   // Command Mailbox
#define APCB_BREAKPOINT_CMD_ABL_BP_FOUND  0x5000C001         // Command from ABL indicating that BP found
#define APCB_BREAKPOINT_CMD_ABL_BP_DONE 0x5000DEAD         // Command from ABL indicating that All BPs are done
#define APCB_BREAKPOINT_CMD_CONTINUE   0xC001C001        // Command from script to ABL indicating continue execution
#define APCB_BREAKPOINT_CMD_EXTERNAL_ENABLE  0xC001BEE5  // Command to enable breakpoints
#define APCB_BREAKPOINT_CMD_BP_LIST  0xC001BB11          // Command from script to indicating


#define APCB_IDS_BREAKPOINT(ApcbBreakpointNumber, StdHeader)\
    if (ApcbIdsBreakpoint(ApcbBreakpointNumber, (StdHeader)))

#define CUSTOM_BP APCB_IDS_BREAKPOINT(APCB_BP_CUSTOM, StdHeader)

//
// APCB BreakPoint Definition
//
typedef struct {
  UINT32   BreakPointsEnabled;        // Indicates if BP are enabled
  UINT32   BreakPointValue;                // BreakPoint Value
} APCB_BREAKPOINT_CONTROL_STRUCT;

//
// DDR Post Package Repair
//
#define MAX_DPPRCL_ENTRY 24
#define MAX_DPPRCL_SOCKETS 2
#define MAX_DPPRCL_CHANNELS 8
#define MAX_DPPRCL_ENTRIES MAX_DPPRCL_SOCKETS*MAX_DPPRCL_CHANNELS*MAX_DPPRCL_ENTRY

#define DPPR_SOFT_REPAIR 0
#define DPPR_HARD_REPAIR 1
#define DPPR_VALID_REPAIR 1
#define DPPR_INVALID_REPAIR 0

#define DPPR_DEVICE_X4   4
#define DPPR_DEVICE_X8   8
#define DPPR_DEVICE_X16  16

#define DPPR_NUM_CACHE_LINES 128
#define DPPR_BUBBLE_COUNT 256

#define DPPR_MAX_X16_DEVICES   72
#define DPPR_MAX_X4_DEVICES   18
#define DPPR_MAX_X8_DEVICES   9

#define DPPR_REPAIR_TARGET_DEVICES 0x1F


typedef struct _APCB_DPPRCL_REPAIR_ENTRY {
  UINT32 Bank:5;                           ///< [4:0] Bank {BG 3:2,BA 1:0}
  UINT32 RankMultiplier:3;                 ///< [7:5] Rank Multiplier
  UINT32 Device:5;                         ///< [12:8] Device width 
                                           ///<        Device = 4, Repair DIMMs with device width x4 only
                                           ///<        Device = 8, Repair DIMMs with device width x8 only
                                           ///<        Device = 16, Repair DIMMs with device width x16 only
                                           ///<        Device = 0x1F - Ignore device width and repair specific devices based on TargetDevice
  UINT32 ChipSelect:2;                     ///< [14:13] ChipSelect
  UINT32 Column:10;                        ///< [24:15] Column Address
  UINT32 RepairType:1;                     ///< [25:25] Hard/soft repair (0=hard, 1=soft)
  UINT32 Valid:1;                          ///< [26:26] Valid entry
  UINT32 TargetDevice:5;                   ///< [31:27] Target Device (only valid if Device = 0x1F)
                                           ///<         x4 (0-17 (with ECC)), x8 (0-8 (with ECC))
  UINT32 Row:18;                           ///< [18:0] Row Address
  UINT32 Socket:3;                         ///< [21:19] Socket
  UINT32 Channel:3;                        ///< [21:19] Channel
  UINT32 Reserverd1:8;                     ///< pad to 32 bit
} APCB_DPPRCL_REPAIR_ENTRY;

BOOLEAN ApcbGetConfigParameter (
  IN     UINT16             ApcbParamToken,
  IN     UINT8              ApcbTimePoint,
  IN OUT UINT8              *Buffer,
  IN OUT UINT8              *Size,
  IN     AMD_CONFIG_PARAMS  *StdHeader
  );

BOOLEAN ApcbGetCbsCmnParameter (
  IN     UINT16             ApcbParamToken,
  IN     UINT8              ApcbTimePoint,
  IN OUT UINT8              *Buffer,
  IN OUT UINT8              *Size,
  IN     AMD_CONFIG_PARAMS  *StdHeader
  );

BOOLEAN ApcbGetCbsDbgParameter (
  IN     UINT16             ApcbParamToken,
  IN     UINT8              ApcbTimePoint,
  IN OUT UINT8              *Buffer,
  IN OUT UINT8              *Size,
  IN     AMD_CONFIG_PARAMS  *StdHeader
  );

BOOLEAN ApcbGetParameter (
  IN     APCB_PARAM_TYPE    ApcbParamType,
  IN     UINT16             ApcbParamToken,
  IN     UINT8              ApcbTimePoint,
  IN OUT UINT8              *Buffer,
  IN OUT UINT8              *Size,
  IN     AMD_CONFIG_PARAMS  *StdHeader
  );

BOOLEAN ApcbAblIdsOverrideCbsCmnParameter  (
  IN     UINT16             ApcbParamToken,
  IN     UINT8              ApcbTimePoint,
  IN OUT UINT8              *Buffer,
  IN OUT UINT8              *Size,
  IN     AMD_CONFIG_PARAMS  *StdHeader
  );

BOOLEAN ApcbAblIdsOverrideCbsDbgParameter  (
  IN     UINT16             ApcbParamToken,
  IN     UINT8              ApcbTimePoint,
  IN OUT UINT8              *Buffer,
  IN OUT UINT8              *Size,
  IN     AMD_CONFIG_PARAMS  *StdHeader
  );

BOOLEAN ApcbAblIdsOverrideCbsCmnChildParameter  (
  IN     UINT16             *ApcbParamTokenList,
  IN     UINT8              ApcbTimePoint,
  IN OUT UINT8              *Buffer,
  IN OUT UINT8              *Size,
  IN     BOOLEAN            Numeric,
  IN     AMD_CONFIG_PARAMS  *StdHeader
  );

BOOLEAN ApcbAblIdsOverrideCbsDbgChildParameter  (
  IN     UINT16             *ApcbParamTokenList,
  IN     UINT8              ApcbTimePoint,
  IN OUT UINT8              *Buffer,
  IN OUT UINT8              *Size,
  IN     BOOLEAN            Numeric,
  IN     AMD_CONFIG_PARAMS  *StdHeader
  );

BOOLEAN ApcbLocateType (
  IN     UINT16   GroupId,
  IN     UINT16   TypeId,
  IN     UINT16   InstanceId,
  IN     UINT32   *TableSize,
  IN OUT VOID     **TypeData
  );

VOID
ApcbErrorLogReportingControlInit (
    IN     AMD_CONFIG_PARAMS  *StdHeader
    );

VOID
ApcbExternalVoltageControlInit (
    IN     AMD_CONFIG_PARAMS  *StdHeader
    );

VOID
ApcbApobParameterInit (
    IN     AMD_CONFIG_PARAMS  *StdHeader
    );

BOOLEAN
ApcbIdsBreakpoint (
  IN       UINT32 ApcbBreakpointNumber,
  IN       AMD_CONFIG_PARAMS *StdHeader
  );

VOID
ApcbIdsBreakpointInit (
  IN       AMD_CONFIG_PARAMS *StdHeader
  );

VOID
ApcbMemOverclockInit (
  IN       AMD_CONFIG_PARAMS  *StdHeader
  );

VOID
ApcbMemOverclockResetCounter (
  IN             BOOLEAN   MemInitSuccess
  );

VOID
ApcbMemOverclockRecovery (
  IN             UINT16   MemOcErrType
  );

UINT32
IdsDbgSmnRead (
  IN       UINT32 SmnAddress
  );

UINT32
IdsDbgSmnWrite (
  IN       UINT32 SmnAddress,
  IN       UINT32 Value
  );

#endif



